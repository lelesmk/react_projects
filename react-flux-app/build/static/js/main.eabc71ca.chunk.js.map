{"version":3,"sources":["components/HomePage.js","components/AboutPage.js","appDispatcher.js","actions/actionTypes.js","stores/courseStore.js","stores/authorStore.js","api/apiUtils.js","api/courseApi.js","actions/courseActions.js","components/CourseList.js","api/authorApi.js","actions/authorActions.js","components/CoursesPage.js","components/AuthorsList.js","components/AuthorsPage.js","common/TextInput.js","common/SelectDropDown.js","components/CourseForm.js","components/ManageCoursePage.js","components/AuthorForm.js","components/ManageAuthorPage.js","common/Header.js","components/NotFoundPage.js","components/App.js","index.js"],"names":["HomePage","className","to","AboutPage","React","Component","dispatcher","Dispatcher","_courses","courseStore","callback","this","on","removeListener","emit","slug","find","course","filter","length","EventEmitter","register","payload","actionType","actionTypes","push","emitChange","courses","map","id","parseInt","_authors","authorStore","author","authors","handleResponse","response","a","ok","json","status","text","error","Error","handleError","console","baseUrl","process","REACT_APP_API_URL","saveCourse","fetch","method","headers","body","JSON","stringify","authorId","then","catch","courseApi","savedCourse","dispatch","loadCourses","deleteCourse","courseId","CourseList","props","getAuthors","saveAuthor","authorApi","savedAuthor","loadAuthors","deleteAuthor","CoursesPage","useState","getCourses","setCourses","setAuthors","useEffect","addChangeListener","onCourseChange","removeChangeListener","onAuthorChange","getAuthorName","courseAuthorId","authorsArray","log","i","name","AuthorsList","AuthorsPage","TextInput","wrapperClass","htmlFor","label","type","onChange","value","defaultProps","SelectDropDown","setOptions","setLoading","unmounted","_options","CourseForm","onSubmit","title","category","ManageCoursePage","errors","setErrors","setCourse","match","params","courseActions","courseFound","getCourseBySlug","history","event","updatedCourse","target","_errors","Object","keys","formIsValid","preventDefault","toast","success","AuthorForm","ManageAuthorPage","setAuthor","authorActions","authorFound","getAuthorById","updatedAuthor","Header","activeStyle","color","exact","NotFoundPage","App","autoClose","hideProgressBar","path","component","render","document","getElementById"],"mappings":"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","file":"static/js/main.eabc71ca.chunk.js","sourcesContent":["/**\n * import npm package React and set it\n * to a variable named react\n */\nimport React from \"react\";\n\nimport { Link } from \"react-router-dom\";\n\n// declare a component - you can use a function or class\nfunction HomePage() {\n  return (\n    <div className=\"jumbotron\">\n      <h1>Pluralsight Administration</h1>\n      <p>React, Flux, and React Router for ultra-responsive web apps.</p>\n      <Link to=\"/about\" className=\"btn btn-primary\">\n        About\n      </Link>\n    </div>\n  );\n}\n\n// export component to grant public access to other files.\nexport default HomePage;\n","/**\n * import npm package React and set it\n * to a variable named react\n */\nimport React from \"react\";\n\n// declare a component - you can use a function or class\nclass AboutPage extends React.Component {\n  render() {\n    return (\n      <>\n        <h2>About</h2>\n        <p>This app uses React.</p>\n      </> // React.Fragment equals <></> forces 1:1 function:top-level element without rendering anything extra\n    );\n  }\n}\n\n// export component to grant public access to other files.\nexport default AboutPage;\n","/**\n *  There's only one dispatcher per application.\n *  The dispatcher is a central hub for the entire\n *  app and holds a list callback functions where\n *  all the actions from the UI will be dispatched\n *  via this dispatcher.\n *\n *  The stores will register with this dispatcher\n *  to be informed when actions occur.\n *\n */\n\n// import Facebook's Flux Dispatcher\nimport { Dispatcher } from \"flux\";\n\n// instantiate dispatcher\nconst dispatcher = new Dispatcher();\n\n// export for global use\nexport default dispatcher;\n","/**\n *  acitonTypes are used by the system and strongly typed\n *  to support autocomplete and prevent typing errors\n *  when declared in stores.\n *\n *  also serves as a quick reference to see all actions\n *  supported by the application.\n */\nexport default {\n  // declare action, then implement api call in courseActions.js\n  CREATE_COURSE: \"CREATE_COURSE\",\n  UPDATE_COURSE: \"UPDATE_COURSE\",\n  DELETE_COURSE: \"DELETE_COURSE\",\n  LOAD_COURSES: \"LOAD_COURSES\",\n\n  // authors actions\n  CREATE_AUTHOR: \"CREATE_AUTHOR\",\n  UPDATE_AUTHOR: \"UPDATE_AUTHOR\",\n  DELETE_AUTHOR: \"DELETE_AUTHOR\",\n  GET_AUTHOR: \"GET_AUTHOR\",\n  LOAD_AUTHORS: \"LOAD_AUTHORS\",\n};\n\n// Creating new actions:\n/**\n *  1. Declare actionTypes\n *  2. Implement courseActions (api calls) and dispatch action playload\n *  3. Use/handle actions in courseStore\n *  4. Implement the UI (import action, pass to jsx via props, add button/link)\n */\n","import { EventEmitter } from \"events\";\n\nimport Dispatcher from \"../appDispatcher\";\n\n// import actionTypes to bundle with the new course\nimport actionTypes from \"../actions/actionTypes\";\n\n/** store needs to emit an event each time\n *  a change occurs. Extend EventEmitter class\n *  to get this behaviour.\n *\n *  ! see node.js docs for events emitter methods. */\n\n// declare event constant to avoid hardcoding\nconst CHANGE_EVENT = \"change\";\n\n// declare a private array to store course data\nlet _courses = [];\n/** course data is not exported/made public - only\n *  the store is exported. The only way to access\n *  the course data will be via public api which\n *  are the functions we declare in this module.\n *  So we can control how course data is managed.\n *\n *  Everytime a courseStore is created, the\n *  CREATE_COURSE action will be dispatched. It will\n *  include the new course as part of the payload.\n *\n *  So we want to take a new course that will be\n *  passed with the action and push it into an array\n *  that stores course data. This implementation is\n *  executed inside the code block where we register\n *  the store to the dispatcher.\n */\n\nclass CourseStore extends EventEmitter {\n  /**\n   *  the below methods provides a way for the UI/React\n   *  components to interact with the store.\n   *  every Flux store must have these 3 functions:\n   *  1. addChangeListener (wraps EventEmitter's 'on' method)\n   *  2. removeChangeListener (wraps EventEmitter's 'removeListener' method)\n   *  3. emitChange (wraps EventEmitter's 'emit' method)\n   */\n  // add listener function to listeners array for the event\n  addChangeListener(callback) {\n    // on() adds a listener to an array of listeners and returns EventEmitter\n    this.on(\n      // name of event\n      CHANGE_EVENT,\n      // when change completes we will call the callback function\n      callback\n    );\n    /** this method will allow react components to subscribe\n     *  to the store to get notified when a chance occurs.\n     *  whatever callback function gets passed in will be\n     *  called anytime things change in the store.\n     */\n  }\n\n  // removes specified listner from the listener array for the event\n  removeChangeListener(callback) {\n    this.removeListener(CHANGE_EVENT, callback);\n    /** this method will allow react components to unsubscribe\n     *  from the store.\n     */\n  }\n  // synchronously calls each listener registered for the event, in order of register\n  emitChange() {\n    this.emit(CHANGE_EVENT);\n  }\n\n  // give read access to private variable _courses\n  getCourses() {\n    return _courses;\n  }\n\n  // find course by slug\n  getCourseBySlug(slug) {\n    // use JS find() method which accepts a boolean function (a 'predicate')\n    /** predicate anonymous function:\n     *  - look through this list of _courses\n     *  - find the course that has slug equal to the slug passed in\n     */\n\n    return _courses.find((course) => course.slug === slug);\n  }\n\n  // redirect if course not found\n  courseFound(slug) {\n    // search for courses that match the slug\n    if (_courses.filter((course) => course.slug === slug).length > 0) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  // TODO: Add other handy functions that searches course data\n}\n\n// instantiate class\nconst courseStore = new CourseStore();\n\n/** dispatcher registration is private to the store\n *  thus defined below the store and not part of the\n *  public api.\n */\n\n/** register method accepts a function that takes in\n *  a payload.\n *  this function will be called/notified of every\n *  single action dispatched.\n *  So we will need a function that switches based on\n *  the actionType that's being passed.\n */\n\n// Register/subscribe to the dispatcher\nDispatcher.register((payload) => {\n  // based on payload dispatched\n  switch (payload.actionType) {\n    // create a new course and save it in a private store array\n    case actionTypes.CREATE_COURSE:\n      _courses.push(payload.course);\n      /** payload.course gets a course from the payload\n       *  dispatched by api functions in courseActions.js\n       *  payload.actionType checked for in the switch\n       *  declaration gets the actionType from the same\n       *  dispatcher payload.\n       *  i.e. the payload is dispatched in courseActions.js\n       *  by Dispatcher.dispatch() and caught here via\n       *  Dispatcher.register().\n       *\n       *  Remember the _course data is private so people\n       *  can't mess with it. We need a getCourses method\n       *  to access course data. Let's define it inside\n       *  the class (we are outside the class here) below\n       *  the emitChange() method.\n       *\n       */\n\n      // emit calls each registered listener\n      courseStore.emitChange();\n      /** emitting a change, will notify any component\n       *  registered with the store. The component will\n       *  know to update the UI accordingly.\n       *  More specifically, any store that calls\n       *  addChangeListener() method will be notified\n       *  every emitChange() is called.\n       */\n      break;\n\n    case actionTypes.LOAD_COURSES:\n      // load courses from payload in private store\n      _courses = payload.courses;\n      // anounce change to store\n      courseStore.emitChange();\n      // Next, decide when to use this action and update CoursesPage\n      /** When do we want the full courses list to load?\n       *  1. When needed (Lazy loading data)?\n       *     - requires a check to see if courses have been loaded\n       *       on each page that needs course data.\n       *\n       *  2. When the app loads regardless of page user is on?\n       *     - if the app needs the same data on many pages, it\n       *       may be better to load the data immediately when the\n       *       app loads regardless of page.\n       *\n       *  (For this app we'll implement lazy loading for learning.)\n       */\n      break;\n\n    case actionTypes.UPDATE_COURSE:\n      /**\n       *  Map over the _courses array and replace the course we want to update.\n       *  (map creates a new array by iterating an existing array.\n       *  we specify what value to put in the new array for each\n       *  element currently in the array.)\n       *  - update private array of courses by mapping over the existing array\n       *  - for each course check if course.id is equal to the payload.course.id\n       *  - if true, replace that course with the payload.course\n       *  - else leave as is\n       */\n      _courses = _courses.map((course) =>\n        course.id === payload.course.id ? payload.course : course\n      );\n\n      courseStore.emitChange();\n      break;\n\n    // delete course\n    case actionTypes.DELETE_COURSE:\n      _courses = _courses.filter(\n        /** for each course in _courses, check if course.id equals payload.id (parse to Int possible string\n         *  and set radix to base 10)\n         *  if function returns true, filter out the match that was deleted.\n         *  this will return a new array of courses with one less course.\n         */\n        (course) => course.id !== parseInt(payload.id, 10) // for filter we pass it a boolean function (a predicate)\n      );\n      courseStore.emitChange();\n      // Next, implement the UI\n      break;\n\n    default:\n    // nothing to do\n    /** Every store's dispatcher receives every action\n     *  dispatched, so if the store isn't interested in\n     *  that action, there's nothing to do.\n     */\n  }\n});\n\n// export store\nexport default courseStore;\n\n/** next, register store with dispatcher so\n *  the store is  notified when an action occurs.*/\n\n//====== BOILERPLATE CODE FOR STORES ====== //\n//========= The shell of a store ========= //\n\n/**\n *  1. Create a class that extends the EventEmitter\n *     to emit an event when an action produced\n *  2. Implement 3 EventEmitter functions to interact with UI\n *     (addChangeListener, removeChangeListener, emitChange)\n *  3. Create an instance of the store\n *  4. Register to the dispatcher so the store get's\n *     called/notified based on the actionType being passed.\n *  5. Implement the action (e.g. create courses and store),\n *     emit the changes, and create methods that access the data.\n *     The CourseStore holds the full list of courses now. React\n *     components/UI don't need to call the api directly to get\n *     course data. All they need to do is call store's methods.\n *\n *  NB! Redux a version of Flux avoids some of this\n *      implementation code. But this understanding makes\n *      it easier to learn Redux. Redux builds upon these\n *      principles.\n */\n","import { EventEmitter } from \"events\";\n\nimport Dispatcher from \"../appDispatcher\";\n\n// import actionTypes to bundle with the new author\nimport actionTypes from \"../actions/actionTypes\";\n\n/** store needs to emit an event each time\n *  a change occurs. Extend EventEmitter class\n *  to get this behaviour.\n *\n *  ! see node.js docs for events emitter methods. */\n\n// declare event constant to avoid hardcoding\nconst CHANGE_EVENT = \"change\";\n\n// declare a private array to store author data\nlet _authors = [];\n\n/** author data is not exported/made public - only\n *  the store is exported. The only way to access\n *  the author data will be via public api which\n *  are the functions we declare in this module.\n *  So we can control how AUTHOR data is managed.\n *\n *  Everytime a authorStore is created, the\n *  CREATE_AUTHOR action will be dispatched. It will\n *  include the new author as part of the payload.\n *\n *  So we want to take a new author that will be\n *  passed with the action and push it into an array\n *  that stores author data. This implementation is\n *  executed inside the code block where we register\n *  the store to the dispatcher.\n */\n\nclass AuthorStore extends EventEmitter {\n  /**\n   *  the below methods provides a way for the UI/React\n   *  components to interact with the store.\n   *  every Flux store must have these 3 functions:\n   *  1. addChangeListener (wraps EventEmitter's 'on' method)\n   *  2. removeChangeListener (wraps EventEmitter's 'removeListener' method)\n   *  3. emitChange (wraps EventEmitter's 'emit' method)\n   */\n  // add listener function to listeners array for the event\n  addChangeListener(callback) {\n    // call on to watch for 'change' event\n    this.on(\n      CHANGE_EVENT,\n      // when change occurs we will call the callback function\n      callback\n    );\n    /** this method will allow react components to subscribe\n     *  to the store to get notified when a chance occurs.\n     *  whatever callback function gets passed in will be\n     *  called anytime things change in the store.\n     */\n  }\n\n  // remove specified listner from the listener array for the event\n  removeChangeListener(callback) {\n    this.removeListener(CHANGE_EVENT, callback);\n    /** this method will allow react components to unsubscribe\n     *  from the store.\n     */\n  }\n  // synchronously calls each listener registered for the event, in order of register\n  emitChange() {\n    this.emit(CHANGE_EVENT);\n  }\n\n  // give read access to private variable _authors\n  getAuthors() {\n    return _authors;\n  }\n\n  // find author by id\n  getAuthorById(id) {\n    // use JS find() method which accepts a boolean function (a 'predicate')\n    /** predicate anonymous function:\n     *  - look through this list of _authors\n     *  - find the author that has id equal to the id passed in\n     */\n\n    return _authors.find((author) => author.id === id);\n  }\n\n  // redirect if author not found\n  authorFound(id) {\n    // search for authors that match the id\n    if (_authors.filter((author) => author.id === id).length > 0) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n}\n\n// instantiate class\nconst authorStore = new AuthorStore();\n\n/** dispatcher registration is private to the store\n *  thus defined below the store and not part of the\n *  public api.\n */\n\n/** register method accepts a function that takes in\n *  an action.\n *  this function will be called/notified of every\n *  single action dispatched.\n *  So we will need a function that switches based on\n *  the actionType that's being passed.\n */\n\n// Register/subscribe to the dispatcher\nDispatcher.register((payload) => {\n  // based on action dispatched\n  switch (payload.actionType) {\n    // create a new author and save it in a private store array\n    case actionTypes.CREATE_AUTHOR:\n      _authors.push(payload.author);\n      /** action.author gets a author from the payload\n       *  dispatched by api functions in authorActions.js\n       *  action.actionType checked for in the switch\n       *  declaration gets the actionType from the same\n       *  dispatcher payload.\n       *  i.e. the action is dispatched in authorActions.js\n       *  by Dispatcher.dispatch() and caught here via\n       *  Dispatcher.register().\n       *\n       *  Remember the _author data is private so people\n       *  can't mess with it. We need a getAuthors method\n       *  to access author data. Let's define it inside\n       *  the class (we are outside the class here) below\n       *  the emitChange() method.\n       *\n       */\n\n      // emit this change made to the store\n      authorStore.emitChange();\n      /** emitting a change, will notify any component\n       *  registered with the store. The component will\n       *  know to update the UI accordingly.\n       *  More specifically, any store that calls\n       *  addChangeListener() method will be notified\n       *  every emitChange() is called.\n       */\n      break;\n\n    case actionTypes.GET_AUTHOR:\n      _authors = payload.author;\n      authorStore.emitChange();\n      break;\n\n    case actionTypes.LOAD_AUTHORS:\n      // load authors from payload in private store\n      _authors = payload.authors;\n      // anounce change to store\n      authorStore.emitChange();\n      // Next, decide when to use this action and update AuthorsPage\n      /** When do we want the full authors list to load?\n       *  1. When needed (Lazy loading data)?\n       *     - requires a check to see if authors have been loaded\n       *       on each page that needs author data.\n       *\n       *  2. When the app loads regardless of page user is on?\n       *     - if the app needs the same data on many pages, it\n       *       may be better to load the data immediately when the\n       *       app loads regardless of page.\n       *\n       *  (For this app we'll implement lazy loading for learning.)\n       */\n      break;\n\n    case actionTypes.UPDATE_AUTHOR:\n      /**\n       *  Map over the _authors array and replace the author we want to update.\n       *  (map creates a new array by iterating an existing array.\n       *  we specify what value to put in the new array for each\n       *  element currently in the array.)\n       *  - update private array of authors by mapping over the existing array\n       *  - for each author check if author.id is equal to the action.author.id\n       *  - if true, replace that author with the action.author\n       *  - else leave as is\n       */\n      _authors = _authors.map((author) =>\n        author.id === payload.author.id ? payload.author : author\n      );\n\n      authorStore.emitChange();\n      break;\n\n    // delete author\n    case actionTypes.DELETE_AUTHOR:\n      _authors = _authors.filter(\n        /** for each author in _authors, check if author.id equals action.id (parse to Int possible string\n         *  and set radix to base 10)\n         *  if function returns true, filter out the match that was deleted.\n         *  this will return a new array of authors with one less author.\n         */\n        (author) => author.id !== parseInt(payload.id, 10) // for filter we pass it a boolean function (a predicate)\n      );\n      authorStore.emitChange();\n      // Next, implement the UI\n      break;\n\n    default:\n    // nothing to do\n    /** Every store's dispatcher receives every action\n     *  dispatched, so if the store isn't interested in\n     *  that action, there's nothing to do.\n     */\n  }\n});\n\n// export store\nexport default authorStore;\n","/**\n *  Centralizes the handling of our API responses.\n */\n\nexport async function handleResponse(response) {\n  if (response.ok) return response.json();\n  if (response.status === 400) {\n    // So, a server-side validation error occurred.\n    // Server side validation returns a string error message, so parse as text instead of json.\n    const error = await response.text();\n    throw new Error(error);\n  }\n  throw new Error(\"Network response was not ok.\");\n}\n\n// In a real app, would likely call an error logging service.\nexport function handleError(error) {\n  // eslint-disable-next-line no-console\n  console.error(\"API call failed. \" + error);\n  throw error;\n}\n","/**\n *  APIs to GET, SAVE, DELETE Courses\n */\n\nimport { handleResponse, handleError } from \"./apiUtils\";\n\n// set environment variable in package.json using cross-env\nconst baseUrl = process.env.REACT_APP_API_URL + \"/courses/\";\n\nexport function getCourses() {\n  return fetch(baseUrl).then(handleResponse).catch(handleError);\n}\n\nexport function getCourseBySlug(slug) {\n  return fetch(baseUrl + \"?slug=\" + slug)\n    .then((response) => {\n      if (!response.ok) throw new Error(\"Network response was not ok.\");\n      return response.json().then((courses) => {\n        if (courses.length !== 1) throw new Error(\"Course not found: \" + slug);\n        return courses[0]; // should only find one course for a given slug, so return it.\n      });\n    })\n    .catch(handleError);\n}\n\nexport function saveCourse(course) {\n  return fetch(baseUrl + (course.id || \"\"), {\n    method: course.id ? \"PUT\" : \"POST\", // POST for create, PUT to update when id already exists.\n    headers: { \"content-type\": \"application/json\" },\n    body: JSON.stringify({\n      ...course,\n      // Parse authorId to a number (in case it was sent as a string).\n      authorId: parseInt(course.authorId, 10),\n    }),\n  })\n    .then(handleResponse)\n    .catch(handleError);\n}\n\nexport function deleteCourse(courseId) {\n  return fetch(baseUrl + courseId, { method: \"DELETE\" })\n    .then(handleResponse)\n    .catch(handleError);\n}\n","import dispatcher from \"../appDispatcher\";\n\n// import courseApi to implement action calls to api\nimport * as courseApi from \"../api/courseApi\";\n\nimport actionTypes from \"./actionTypes\";\n\n// ! the below function is called an Action Creator ! //\nexport function saveCourse(course) {\n  // call courseApi to save a course passed in by this function\n  /** return the promise from the call to api so\n   *  the caller of this function will be notified\n   *  when the promise resolves/completes */\n  return courseApi.saveCourse(course).then((savedCourse) => {\n    // returns savedCourse\n    // handle saved course response\n    /** use flux dispatcher to notify all the stores\n     *  that a course was just created. Stores will\n     *  take the data payload dispatched here and\n     *  put it to use.\n     */\n    dispatcher.dispatch(\n      // an action is an object with actionType property\n      {\n        // ! the below properties declared make up the Action ! //\n\n        // required property\n\n        // actionType: \"CREATE_COURSE\",\n        /**\n         *  actionType is hardcoded as a magic string.\n         *  this requires carefully typing it the\n         *  exact same way when declaring the store\n         *  which will handle the action.\n         *\n         *  instead its best practice to create a\n         *  constant file that contains a list of\n         *  all the actionTypes used in the system\n         *  (actionType is a constant so assigned\n         *  with uppercase.)\n         *\n         */\n\n        // call actionTypes object instead of hardcoding\n\n        /** call action based on whether a we're working on\n         *  an existing course or new course.\n         */\n        actionType: course.id // if course has an id\n          ? actionTypes.UPDATE_COURSE // then UPDATE\n          : actionTypes.CREATE_COURSE, // else CREATE\n\n        // optional properties to pass with action object\n        course: savedCourse,\n      }\n    );\n  });\n}\n\n// declare flux call to api\nexport function loadCourses() {\n  return courseApi.getCourses().then((courses) => {\n    // returns courses array\n    // dispatch courses array payload with action\n    dispatcher.dispatch({\n      actionType: actionTypes.LOAD_COURSES,\n      courses: courses,\n    });\n  });\n\n  // Next, update the courseStore to handle this actionType\n}\n\n// delete course by id\nexport function deleteCourse(id) {\n  return courseApi.deleteCourse(id).then(() => {\n    // empty return ()\n    // dispatch courses array payload with action\n    dispatcher.dispatch({\n      actionType: actionTypes.DELETE_COURSE,\n      id: id,\n    });\n  });\n}\n","import React from \"react\";\nimport PropTypes from \"prop-types\";\nimport { Link } from \"react-router-dom\";\n\nfunction CourseList(props) {\n  return (\n    <table className=\"table\">\n      <thead>\n        <tr>\n          <th>Title</th>\n          <th>Author</th>\n          <th>Category</th>\n          <th>&nbsp;</th>\n        </tr>\n      </thead>\n      <tbody>\n        {/** - iterate this courses passed in via props and\n         *   - call map on that array of courses.\n         *   - map returns an array. */}\n        {props.courses.map((course) => {\n          return (\n            /** - for each course return a table row array.\n             *  - assign a unique key to child in array so\n             *  React can track each element when we create\n             *  multiple instances of an element in the array\n             *  using React components. Now when we add or remove\n             *  different elements (row is an element) React\n             *  can maintain proper state so the order of\n             *  these element doesn't get destroyed when we\n             *  re-render the application.\n             */\n            <tr key={course.id}>\n              <td>\n                <Link to={\"/course/\" + course.slug}>{course.title}</Link>\n              </td>\n              <td>{props.getAuthorName(course.authorId - 1, props.authors)}</td>\n              <td>{course.category}</td>\n              <td>\n                <button\n                  className=\"btn btn-outline-danger\"\n                  onClick={() => props.deleteCourse(course.id)}\n                >\n                  Delete\n                </button>\n              </td>\n            </tr>\n          );\n        })}\n      </tbody>\n    </table>\n  );\n}\n\nexport default CourseList;\n\nCourseList.propTypes = {\n  // delete course\n  deleteCourse: PropTypes.func.isRequired,\n  // courses\n  courses: PropTypes.arrayOf(\n    PropTypes.shape({\n      id: PropTypes.number.isRequired,\n      title: PropTypes.string.isRequired,\n      authorId: PropTypes.number.isRequired,\n      category: PropTypes.string.isRequired,\n    })\n  ).isRequired,\n};\n","/**\n *  APIs to GET, SAVE, DELETE Authors\n */\n\nimport { handleResponse, handleError } from \"./apiUtils\";\nconst baseUrl = process.env.REACT_APP_API_URL + \"/authors/\";\n\nexport function getAuthors() {\n  return fetch(baseUrl).then(handleResponse).catch(handleError);\n}\n\nexport function getAuthorById(id) {\n  return fetch(`baseUrl ${id}`)\n    .then((response) => {\n      if (!response.ok) throw new Error(\"Network response was not ok.\");\n      return response.json().then((authors) => {\n        if (authors.length !== 1) throw new Error(\"Author not found: \" + id);\n        return authors[0]; // should only find one author for a given slug, so return it.\n      });\n    })\n    .catch(handleError);\n}\n\nexport function saveAuthor(author) {\n  return fetch(baseUrl + (author.id || \"\"), {\n    method: author.id ? \"PUT\" : \"POST\", // POST for create, PUT to update when id already exists.\n    headers: { \"content-type\": \"application/json\" },\n    body: JSON.stringify(author),\n  })\n    .then(handleResponse)\n    .catch(handleError);\n}\n\nexport function deleteAuthor(authorId) {\n  return fetch(baseUrl + authorId, { method: \"DELETE\" })\n    .then(handleResponse)\n    .catch(handleError);\n}\n","import dispatcher from \"../appDispatcher\";\n\n// import authorApi to implement action calls to api\nimport * as authorApi from \"../api/authorApi\";\n\nimport actionTypes from \"./actionTypes\";\n\n// ! the below function is called an Action Creator ! //\nexport function saveAuthor(author) {\n  // call authorApi to save a author passed in by this function\n  /** return the promise from the call to api so\n   *  the caller of this function will be notified\n   *  when the promise resolves/completes */\n  return authorApi.saveAuthor(author).then((savedAuthor) => {\n    // returns savedAuthor\n    // handle saved author response\n    /** use flux dispatcher to notify all the stores\n     *  that a author was just created. Stores will\n     *  take the data payload dispatched here and\n     *  put it to use.\n     */\n    dispatcher.dispatch(\n      // an action is an object with actionType property\n      {\n        // ! the below properties declared make up the Action ! //\n\n        // required property\n\n        // actionType: \"CREATE_AUTHOR\",\n        /**\n         *  actionType is hardcoded as a magic string.\n         *  this requires carefully typing it the\n         *  exact same way when declaring the store\n         *  which will handle the action.\n         *\n         *  instead its best practice to create a\n         *  constant file that contains a list of\n         *  all the actionTypes used in the system\n         *  (actionType is a constant so assigned\n         *  with uppercase.)\n         *\n         */\n\n        // call actionTypes object instead of hardcoding\n\n        /** call action based on whether a we're working on\n         *  an existing author or new author.\n         */\n        actionType: author.id // if author has an id\n          ? actionTypes.UPDATE_AUTHOR // then UPDATE\n          : actionTypes.CREATE_AUTHOR, // else CREATE\n\n        // optional properties to pass with action object\n        author: savedAuthor,\n      }\n    );\n  });\n}\n\n// declare flux call to api\nexport function loadAuthors() {\n  return authorApi.getAuthors().then((authors) => {\n    // returns authors array\n    // dispatch authors array payload with action\n    dispatcher.dispatch({\n      actionType: actionTypes.LOAD_AUTHORS,\n      authors: authors,\n    });\n  });\n\n  // Next, update the authorStore to handle this actionType\n}\n\n// get author by id\nexport function getAuthorById(id) {\n  return authorApi.getAuthorById(id).then((author) => {\n    // empty return ()\n    // dispatch authors array payload with action\n    dispatcher.dispatch({\n      actionType: actionTypes.GET_AUTHOR,\n      author: author,\n    });\n  });\n}\n\n// delete author by id\nexport function deleteAuthor(id) {\n  return authorApi.deleteAuthor(id).then(() => {\n    // empty return ()\n    // dispatch courses array payload with action\n    dispatcher.dispatch({\n      actionType: actionTypes.DELETE_AUTHOR,\n      id: id,\n    });\n  });\n}\n","import React, { useState, useEffect } from \"react\";\n\n// import function to call from mock api\nimport courseStore from \"../stores/courseStore\";\nimport authorStore from \"../stores/authorStore\";\n\nimport { loadCourses, deleteCourse } from \"../actions/courseActions\";\n\n// import logic into our page markup\nimport CourseList from \"../components/CourseList\";\nimport { Link } from \"react-router-dom\";\nimport { loadAuthors } from \"../actions/authorActions\";\n\n// FUNCTION COMPONENT WITH HOOKS\n/**======================================= */\n\nfunction CoursesPage() {\n  // declare state with useState hook\n  /** - useState hook returns an array with two values\n   *   [ nameOfSate, nameOfSetterMethod ]\n   *  - initialise state with the courses held in CourseStore\n   */\n  const [courses, setCourses] = useState(courseStore.getCourses());\n  const [authors, setAuthors] = useState(authorStore.getAuthors());\n\n  // call useEffect to make call to store to get courses\n  useEffect(() => {\n    //===== useEffect body is code to run when the component mounts =====//\n\n    // on MOUNTING: subsctibe to Flux store to listen for changes\n    /** addChangeListener accepts a function to call\n     *  when the store changes.\n     *  Remember to clean component when adding a change listener\n     *  on MOUNT by calling removeChangeListener when component\n     *  UNMOUNTS.\n     */\n    courseStore.addChangeListener(onCourseChange);\n\n    // load courses if this request is made for the first time\n    /**\n     *  - check if courseStore has any courses loaded from api\n     *  - if no courses, then call loadCourses from imported courseActions\n     */\n    if (courseStore.getCourses().length === 0) {\n      loadCourses();\n    }\n\n    //===== useEffect return is code to run on umount =====//\n\n    // on UNMOUNTING (navigating to a different page) return this function\n    /** useEffect lets declare the code to run when a component UNMOUNTS\n     *  by returning a funciton.\n     */\n    return () => courseStore.removeChangeListener(onCourseChange); // clean up on unmount (navigate to a different page)\n\n    //===== useEffect [] dependency array is code to run everytime a re-render occurs =====//\n    /** when dependency array is empty, we're specifying the body to run once */\n  }, []);\n\n  useEffect(() => {\n    authorStore.addChangeListener(onAuthorChange);\n\n    // load authors state with array of authors\n    if (authorStore.getAuthors().length === 0) {\n      loadAuthors();\n    }\n\n    return () => authorStore.removeChangeListener(onAuthorChange);\n  }, []);\n\n  function getAuthorName(courseAuthorId, authorsArray) {\n    console.log(\"searchAuthor() runs...\");\n    for (let i = 0; i < authorsArray.length; i++) {\n      console.log(\"authorsArray[i].name: \" + authorsArray[courseAuthorId].name);\n      return authorsArray[courseAuthorId].name;\n    }\n  }\n\n  return (\n    <>\n      <h2>Courses</h2>\n      {/** - add course button to ManageCoursePage component */}\n      <Link to=\"/course\" className=\"btn btn-primary\">\n        Add Course\n      </Link>\n      {/** - call child component\n       *   - use props to pass courses array\n       *     from parent to child\n       *  (props are like html attributes for react components)\n       */}\n      <CourseList\n        courses={courses}\n        deleteCourse={deleteCourse}\n        authors={authors}\n        getAuthorName={getAuthorName}\n      />\n    </>\n  );\n\n  // execute function when a course is added to the store\n  function onCourseChange() {\n    // request courses from store and add/set to this component state\n    setCourses(courseStore.getCourses());\n\n    /** what this says is:\n     *  - getCourses from the api\n     *  - when the api call completes, then\n     *  - store the array of courses in state */\n  }\n\n  function onAuthorChange() {\n    setAuthors(authorStore.getAuthors());\n  }\n  // SUMMARY OF STATE OF CONCERNS\n  /**\n   *  This separates Smart component (CoursesPage) from\n   *  the Dumb component (CourseList).\n   *  Our controller view / smart component\n   *    1. Requests courses from the store\n   *    2. Sets the state 'courses'\n   *    3. Passes that state (course array) to child\n   *       CourseList for rendering\n   *  The CourseList does nothing but define the markup\n   *  and receives an array of courses via props.\n   *\n   */\n}\n\n// CLASS COMPONENT WITH LIFECYCLE METHODS\n/**======================================= */\n// class CoursesPage extends React.Component {\n//   // store list of courses in state\n//   // store state by constructor\n//   //   constructor(props) {\n//   //     super(props);\n\n//   //     // declare state as an object\n//   //     this.state = {\n//   //       courses: [],\n//   //     };\n//   //   }\n\n//   // OR simply declare state without constructor\n//   state = {\n//     courses: [],\n//   };\n\n//   // call lifecycle method for making API calls\n//   componentDidMount() {\n//     // the component must be mounted before calling setSate()\n\n//     // /**\n//     //  *  - returns a promise based api - a future value\n//     //  *  - .then() handles the future response value */\n//     // getCourses().then(\n//     //   //   /**\n//     //   //    *  - function call will be resolved when the\n//     //   //    *    api call is completed.\n//     //   //    *  - the anonymous function(courses) receives an\n//     //   //    *    array of courses returned by getCourses() api call */\n//     //   function (courses) {\n//     //     //     /**\n//     //     //      *  - now we have a reference to the list of courses\n//     //     //      *    and ready to set state.\n//     //     //      *  - setSate accepts an object that describes the new\n//     //     //      *    new properties that we'd like to set in state.\n//     //     //      *  - set courses object with the courses list properties\n//     //     //      *    we've just received.*/\n//     //     this.setState({ courses: courses });\n//     //   }\n//     // );\n//     // more concise Arrow Function syntax\n//     getCourses().then((courses) => this.setState({ courses: courses }));\n//     /** what this says is:\n//      *  - getCourses from the api\n//      *  - when the api call completes, then\n//      *  - store the array of courses in state */\n//   }\n\n//   // display state in table\n//   render() {\n//     return (\n//       <>\n//         <h2>Courses</h2>\n//         <table className=\"table\">\n//           <thead>\n//             <tr>\n//               <th>Title</th>\n//               <th>Author ID</th>\n//               <th>Category</th>\n//             </tr>\n//           </thead>\n//           <tbody>\n//             {/** - iterate this state.courses and\n//              *   - call map on that array of courses.\n//              *   - map returns an array. */}\n//             {this.state.courses.map((course) => {\n//               return (\n//                 /** - for each course return a table row array.\n//                  *  - assign a unique key to child in array so\n//                  *  React can track each element when we create\n//                  *  multiple instances of an element in the array\n//                  *  using React components. Now when we add or remove\n//                  *  different elements (row is an element) React\n//                  *  can maintain proper state so the order of\n//                  *  these element doesn't get destroyed when we\n//                  *  re-render the application.\n//                  */\n//                 <tr key={course.id}>\n//                   <td>{course.title}</td>\n//                   <td>{course.authorId}</td>\n//                   <td>{course.category}</td>\n//                 </tr>\n//               );\n//             })}\n//           </tbody>\n//         </table>\n//       </>\n//     );\n//   }\n// }\n\nexport default CoursesPage;\n","import React from \"react\";\nimport PropTypes from \"prop-types\";\nimport { Link } from \"react-router-dom\";\n\nfunction AuthorsList(props) {\n  return (\n    <table className=\"table\">\n      <thead>\n        <tr>\n          <th>Author</th>\n          <th>Admin Panel</th>\n          <th>&nbsp;</th>\n        </tr>\n      </thead>\n      <tbody>\n        {/** - iterate this courses passed in via props and\n         *   - call map on that array of courses.\n         *   - map returns an array. */}\n        {props.authors.map((author) => {\n          return (\n            /** - for each course return a table row array.\n             *  - assign a unique key to child in array so\n             *  React can track each element when we create\n             *  multiple instances of an element in the array\n             *  using React components. Now when we add or remove\n             *  different elements (row is an element) React\n             *  can maintain proper state so the order of\n             *  these element doesn't get destroyed when we\n             *  re-render the application.\n             */\n            <tr key={author.id}>\n              <td>\n                <Link to={\"/author/\" + author.id}>\n                  {props.getAuthorName(author.id - 1, props.authors)}\n                </Link>\n              </td>\n              <td>\n                <Link\n                  to={\"/author/\" + author.id}\n                  className=\"btn btn-outline-warning\"\n                >\n                  Edit\n                </Link>\n              </td>\n              <td>\n                <button\n                  className=\"btn btn-outline-danger\"\n                  onClick={() => props.deleteAuthor(author.id)}\n                >\n                  Delete\n                </button>\n              </td>\n            </tr>\n          );\n        })}\n      </tbody>\n    </table>\n  );\n}\n\nexport default AuthorsList;\n\nAuthorsList.propTypes = {\n  // delete course\n  deleteAuthor: PropTypes.func.isRequired,\n  // courses\n  author: PropTypes.arrayOf(\n    PropTypes.shape({\n      id: PropTypes.number.isRequired,\n      name: PropTypes.string.isRequired,\n    })\n  ).isRequired,\n};\n","import React, { useState, useEffect } from \"react\";\n\n// import function to call from mock api\nimport authorStore from \"../stores/authorStore\";\n\nimport { loadAuthors, deleteAuthor } from \"../actions/authorActions\";\n\n// import logic into our page markup\nimport { Link } from \"react-router-dom\";\n\nimport AuthorsList from \"../components/AuthorsList\";\n\n// FUNCTION COMPONENT WITH HOOKS\n/**======================================= */\n\nfunction AuthorsPage() {\n  // declare state with useState hook\n  /** - useState hook returns an array with two values\n   *   [ nameOfSate, nameOfSetterMethod ]\n   *  - initialise state with the authors held in authorStore\n   */\n  const [authors, setAuthors] = useState(authorStore.getAuthors());\n\n  useEffect(() => {\n    authorStore.addChangeListener(onAuthorChange);\n\n    // load authors state with array of authors\n    if (authorStore.getAuthors().length === 0) {\n      loadAuthors();\n    }\n\n    return () => authorStore.removeChangeListener(onAuthorChange);\n  }, []);\n\n  function getAuthorName(courseAuthorId, authorsArray) {\n    console.log(\"searchAuthor() runs...\");\n    for (let i = 0; i < authorsArray.length; i++) {\n      console.log(\"authorsArray[i].name: \" + authorsArray[courseAuthorId].name);\n      return authorsArray[courseAuthorId].name;\n    }\n  }\n\n  return (\n    <>\n      <h2>Authors</h2>\n      {/** - add course button to ManageCoursePage component */}\n      <Link to=\"/author\" className=\"btn btn-primary\">\n        Add Author\n      </Link>\n      {/** - call child component\n       *   - use props to pass courses array\n       *     from parent to child\n       *  (props are like html attributes for react components)\n       */}\n      <AuthorsList\n        authors={authors}\n        deleteAuthor={deleteAuthor}\n        getAuthorName={getAuthorName}\n      />\n    </>\n  );\n\n  // execute function when a course is added to the store\n  function onAuthorChange() {\n    // request authors from store and add/set to this component state\n    setAuthors(authorStore.getAuthors());\n  }\n}\n\nexport default AuthorsPage;\n","/** Reuseable code for form inputs */\n\nimport React from \"react\";\n\n/** define PropTypes whenever a reusable component is created\n *  so other devs understand what data to pass down and to\n *  get warnings if we forget to pass the expected data down.\n */\nimport PropTypes from \"prop-types\";\n\nfunction TextInput(props) {\n  /** Bootstrap requires a has-error class on the\n   *  form group wrapper if the input has an error.\n   *\n   *  - start with default value \"form-group\"\n   *  - if props.error is set && the error isn't an\n   *    empty string\n   *      then concatenate another class to wrapperClass\n   */\n  let wrapperClass = \"form-group\";\n  // Dynamically add a Bootstrap class name\n  if (props.error.length > 0) {\n    wrapperClass += \" has-error\";\n    /** Bootstrapper has-error class will add a\n     *  red line around the input when it is in\n     *  an error state.\n     */\n  }\n  return (\n    <div className={wrapperClass}>\n      <label htmlFor={props.id}>{props.label}</label>\n      <div className=\"field\">\n        <input\n          id={props.id}\n          type=\"text\"\n          onChange={props.onChange}\n          name={props.name}\n          className=\"form-control\"\n          value={props.value}\n        />\n      </div>\n      {/** Display validation error below input */}\n      {props.error && <div className=\"alert alert-danger\">{props.error}</div>}\n    </div>\n  );\n}\n\n// declare PropTypes\nTextInput.propTypes = {\n  id: PropTypes.string.isRequired,\n  name: PropTypes.string.isRequired,\n  label: PropTypes.string.isRequired,\n  onChange: PropTypes.func.isRequired,\n  value: PropTypes.string,\n  error: PropTypes.string,\n};\n// declare default PropTypes\nTextInput.defaultProps = {\n  // if no error passed in, default to empty string\n  error: \"\",\n};\n\nexport default TextInput;\n","import React, { useState, useEffect } from \"react\";\nimport { getAuthors } from \"../api/authorApi\";\n\nfunction SelectDropDown(props) {\n  // 1. Set initial value of state and return current value\n  const [options, setOptions] = useState([{ value: \"\", label: \"Loading...\" }]);\n\n  // 4. Stop use from interacting with dropdown while loading\n  const [loading, setLoading] = useState(true);\n\n  // 6. Control dropdown value selected in state and set initial value\n  //   const [value, setValue] = useState(\"Select author\");\n\n  let wrapperClass = \"form-group\";\n  // Dynamically add a Bootstrap class name\n  if (props.error.length > 0) {\n    wrapperClass += \" has-error\";\n    /** Bootstrapper has-error class will add a\n     *  red line around the input when it is in\n     *  an error state.\n     */\n  }\n\n  useEffect(\n    () =>\n      /** first parameter is a function to execute when\n       *  the side effect runs */\n      {\n        // 5. Set unmounted flag to set state only if use is still on the page\n        let unmounted = false;\n\n        // 3. Fetch data from a API if use is still mounted\n        if (!unmounted) {\n          getAuthors().then((_options) =>\n            setOptions(\n              _options.map(({ id, name }) => ({ value: id, label: name }))\n            )\n          );\n\n          // 4. Enable dropdown after loading\n          setLoading(false);\n        }\n\n        // on unmount -> 5\n        return () => {\n          unmounted = true;\n        };\n      },\n    /** second parameter determines when the side effect runs.\n     *  In our case this is just after the component first\n     *  renders because we have specified an empty array */\n    []\n  );\n\n  // 2. Map current value of state to select dropdown options\n  return (\n    /** diabable while loading -> 4\n     *  bind value in state to value prop on select element -> 6\n     *  update this state in a change event listener with onChange prop ->6\n     */\n    <div className={wrapperClass}>\n      <label htmlFor={props.id}>{props.label}</label>\n      <div className=\"field\">\n        <select\n          id={props.id}\n          name={props.name}\n          className=\"form-control\"\n          disabled={loading}\n          onChange={props.onChange}\n          value={props.value}\n        >\n          {/** iterate current value and label props in state*/}\n          {options.map((item) => (\n            /** render the relevant option element */\n\n            <option key={item.value} value={item.value}>\n              {item.label}\n            </option>\n          ))}\n        </select>\n      </div>\n      {/** Display validation error below input */}\n      {props.error && <div className=\"alert alert-danger\">{props.error}</div>}\n    </div>\n  );\n}\n\n// declare default PropTypes\nSelectDropDown.defaultProps = {\n  // if no error passed in, default to empty string\n  error: \"\",\n};\n\nexport default SelectDropDown;\n","import React from \"react\";\n\n// consume reusable TextInput component\nimport TextInput from \"../common/TextInput\";\n\n// import PropTypes\nimport PropTypes from \"prop-types\";\nimport SelectDropDown from \"../common/SelectDropDown\";\n\nfunction CourseForm(props) {\n  return (\n    <form onSubmit={props.onSubmit}>\n      {/** insert onSubmit on form tag rather than the\n       *   submit button for better accessibility. User\n       *   can click Save button or hit Enter to submit. */}\n      <TextInput\n        id=\"title\"\n        label=\"Title\"\n        onChange={props.onChange}\n        name=\"title\"\n        value={props.course.title}\n      />\n\n      <SelectDropDown\n        id=\"author\"\n        label=\"Author\"\n        name=\"authorId\"\n        onChange={props.onChange}\n        value={props.course.authorId || \"\"}\n      />\n      {/* <Select\n            id=\"author\"\n            name=\"authorId\"\n            options={props.options(props.authors)}\n            value={props.selectedOption || \"\"}\n            className=\"mb-3\"\n            onChange={props.onAuthorChange}\n            placeholder=\"Select author\"\n            isSearchable\n          ></Select> */}\n\n      <TextInput\n        id=\"category\"\n        label=\"Category\"\n        name=\"category\"\n        onChange={props.onChange}\n        value={props.course.category}\n      />\n\n      <input type=\"submit\" value=\"Save\" className=\"btn btn-primary\" />\n    </form>\n  );\n}\n\n// declare PropTypes\nCourseForm.propTypes = {\n  course: PropTypes.object.isRequired,\n  onSubmit: PropTypes.func.isRequired,\n  onChange: PropTypes.func.isRequired,\n  errors: PropTypes.object.isRequired,\n};\n\nexport default CourseForm;\n","/* eslint-disable no-restricted-globals */\nimport React, { useState, useEffect } from \"react\";\nimport CourseForm from \"./CourseForm\";\n\n// import toast notifications\nimport { toast } from \"react-toastify\";\n\n// import store to access payloads from the api\nimport courseStore from \"../stores/courseStore\";\n\n// import actions to interact with the store and not the api directly\nimport * as courseActions from \"../actions/courseActions\";\n\n/** Arrow function component with props received */\nconst ManageCoursePage = (props) => {\n  /**\n   *  - declare client side validation state\n   *  - initialise with empty object */\n  const [errors, setErrors] = useState({});\n\n  // Connect page to Flux store\n  /** store the list of courses from the Flux store in state,\n   *  then connect to the store in on Mount - useEffect()\n   */\n  const [courses, setCourses] = useState(courseStore.getCourses());\n\n  /**\n   *  - declare state to hold course form data\n   *  - initialise with an empty course object\n   * */\n  const [course, setCourse] = useState({\n    id: null,\n    slug: \"\",\n    title: \"\",\n    authorId: null,\n    category: \"\",\n  });\n\n  // Edit course\n  useEffect(() => {\n    // connect/subscribe to the flux store\n    courseStore.addChangeListener(onChange); // run onChange() callback when courseStore changes\n\n    // get slug from querry parameters\n    const slug = props.match.params.slug; // pulled from path '/courses/:slug' in App.js\n\n    // Find course by slug\n    /** if the user access this page directly we need to check\n     *  if courses have been loaded into the Flux store.\n     *  if courses have not been load we need to ask the Flux\n     *  store to load them before the use can access a course.\n     */\n\n    // on page load check if there's any courses in state yet\n    if (courses.length === 0) {\n      // if no courses in courses array we load them\n      /** when this change is completed the\n       *  callback onChange() is executed and\n       *  updated the array of courses.\n       *  since courses.length is listed in the\n       *  dependency array below, useEffect will run again.*/\n      courseActions.loadCourses();\n    } else if (slug) {\n      // get course from store and update the course\n      /** getCourseBySlug returns a course with a specified slug\n       *  from the flux store. The result is passed to setCourse().\n       */\n\n      if (courseStore.courseFound(slug) === true) {\n        setCourse(courseStore.getCourseBySlug(slug)); // from path '/courses/:slug'\n      } else {\n        props.history.push(\"/404\");\n      }\n    }\n\n    // on UNMOUNTING (navigating to a different page) return this function\n    /** useEffect lets declare the code to run when a component UNMOUNTS\n     *  by returning a funciton.\n     */\n    return () => courseStore.removeChangeListener(onChange); // clean addChangeListener new page is rendered\n  }, [props.history, courses.length, props.match.params.slug]); // declare a dependancy array\n  /** If anything in the dependency array changes, useEffect will re-run.\n   *  When useEffect runs the second time after courses are loaded\n   *  courses.length will not be 0 and if there's a slug in the url\n   *  it will ask the store for the relevant course, and the course\n   *  will be there because the array of courses  has already been\n   *  populated in the Flux store.\n   */\n\n  // declare change handler to enable form inputs\n  function handleChange(event) {\n    /**\n     *  - use ...spread operator to copy state for editing\n     *  - set value passed in by form event based on the\n     *    name property of element e.g.\n     *    if attribute name=\"title\",\n     *    then value will be stored in course.title\n     *    and intialised to a variable prop [event.target.name]\n     *    called a Computed Property\n     *    which can be used by each form input.\n     *  - pass updated course to setCourse function*/\n    const updatedCourse = {\n      // copy the course object\n      ...course,\n      // set the title property on the copy to the value passed in on the event\n      [event.target.name]: event.target.value,\n      // [event.target.name]: event.target.value,\n    };\n    // pass the updatedCourse to the setCourse function\n    setCourse(updatedCourse);\n  }\n  // Rename authors array keys to html options tag attributes\n  // function options(options) {\n  //   // map object array\n  //   return (options = options.map((item) => {\n  //     debugger;\n  //     // copy object array and rename keys to value and label\n  //     return { value: item.id, label: item.name };\n  //   }));\n  // }\n\n  // execute function when a course is added to the store\n  function onChange() {\n    // request courses from store and add/set to this component state\n    setCourses(courseStore.getCourses());\n    /** what this says is:\n     *  - getCourses from the api\n     *  - when the api call completes, then\n     *  - store the array of courses in state */\n  }\n\n  // form validation function\n  function formIsValid() {\n    // declare local errors object\n    const _errors = {};\n\n    // initialise errors if course props empty\n    if (!course.title) _errors.title = \"Title is required\";\n    if (!course.authorId) _errors.authorId = \"Author ID is required\";\n    if (!course.category) _errors.category = \"Category is required\";\n\n    // pass validation error result\n    setErrors(_errors);\n\n    // form is valid if the errors object has no properties\n    return Object.keys(_errors).length === 0; // returns boolean\n    /**\n     *  the Object.keys returns an array of an object's keys.\n     *  if the array of keys for the _errors' object is 0 then\n     *  the errors object has no properties.\n     */\n  }\n\n  // declare submit handler\n  // automatically receives an event from browser\n  function handleSubmit(event) {\n    // handle form validation\n    /** if the form is not valid then do nothing. */\n    if (!formIsValid()) return;\n\n    // to handle event on client, call prevent default post to server\n    event.preventDefault();\n\n    // call courseActions (instead of directly calling the api)\n    courseActions\n      // pass the course held in state\n      .saveCourse(course)\n\n      /** all the api functions return a promise so we could\n       *  declare .then() to specify what should happen after\n       *  the saveCourse is completed.\n       */\n      .then(() => {\n        // redirect back to CoursesPage\n        props.history.push(\"/courses\");\n        /** since Add Course was loaded via\n         * React Router's Route we have access to\n         * React Router's history object on props.\n         * So we can programmatically redirect the\n         * user after the save is completed. */\n\n        // display notification after success save\n        toast.success(\"Course saved.\");\n      });\n  }\n\n  return (\n    <>\n      <h2>Manage Course</h2>\n      {/** Pass down to CourseForm child component via props\n       *  - pass down course state object\n       *  - pass down change handler\n       *  - pass down save form handler\n       *  - pass down validation errors */}\n      <CourseForm\n        course={course}\n        onChange={handleChange}\n        onSubmit={handleSubmit}\n        errors={errors}\n      />\n    </>\n  );\n};\n\nexport default ManageCoursePage;\n\n// then create a route in App.js\n","import React from \"react\";\n\n// consume reusable TextInput component\nimport TextInput from \"../common/TextInput\";\n\n// import PropTypes\nimport PropTypes from \"prop-types\";\n\nfunction AuthorForm(props) {\n  return (\n    <form onSubmit={props.onSubmit}>\n      {/** insert onSubmit on form tag rather than the\n       *   submit button for better accessibility. User\n       *   can click Save button or hit Enter to submit. */}\n      <TextInput\n        id={props.id}\n        label=\"Author\"\n        onChange={props.onChange}\n        name=\"author\"\n        value={props.author.name}\n        error={props.errors.name}\n      />\n\n      <input type=\"submit\" value=\"Save\" className=\"btn btn-primary\" />\n    </form>\n  );\n}\n\n// declare PropTypes\nAuthorForm.propTypes = {\n  name: PropTypes.string.isRequired,\n  onSubmit: PropTypes.func.isRequired,\n  onChange: PropTypes.func.isRequired,\n  errors: PropTypes.object.isRequired,\n};\n\nexport default AuthorForm;\n","/* eslint-disable no-restricted-globals */\nimport React, { useState, useEffect } from \"react\";\nimport AuthorForm from \"./AuthorForm\";\n\n// import toast notifications\nimport { toast } from \"react-toastify\";\n\n// import store to access payloads from the api\nimport authorStore from \"../stores/authorStore\";\n\n// import actions to interact with the store and not the api directly\nimport * as authorActions from \"../actions/authorActions\";\n\n/** Arrow function component with props received */\nconst ManageAuthorPage = (props) => {\n  /**\n   *  - declare client side validation state\n   *  - initialise with empty object */\n  const [errors, setErrors] = useState({});\n\n  // Connect page to Flux store\n  /** store the list of authors from the Flux store in state,\n   *  then connect to the store in on Mount - useEffect()\n   */\n  const [authors, setAuthors] = useState(authorStore.getAuthors());\n\n  /**\n   *  - declare state to hold author form data\n   *  - initialise with an empty author object\n   * */\n  const [author, setAuthor] = useState({\n    id: null,\n    name: \"\",\n  });\n  // Edit author\n  useEffect(() => {\n    // connect/subscribe to the flux store\n    authorStore.addChangeListener(onChange); // run onChange() callback when authorStore changes\n\n    // get id from querry parameters\n    const id = props.match.params.id; // pulled from path '/authors/:id' in App.js\n\n    // Find author by id\n    /** if the user access this page directly we need to check\n     *  if authors have been loaded into the Flux store.\n     *  if authors have not been load we need to ask the Flux\n     *  store to load them before the use can access a author.\n     */\n\n    // on page load check if there's any authors in state yet\n    if (authors.length === 0) {\n      // if no authors in authors array we load them\n      /** when this change is completed the\n       *  callback onChange() is executed and\n       *  updated the array of authors.\n       *  since authors.length is listed in the\n       *  dependency array below, useEffect will run again.*/\n      authorActions.loadAuthors();\n    } else if (id) {\n      // get author from store and update the author\n      /** getAuthorById returns a author with a specified id\n       *  from the flux store. The result is passed to setAuthor().\n       */\n\n      if (authorStore.authorFound(id) === true) {\n        setAuthor(authorStore.getAuthorById(id)); // from path '/authors/:id'\n      } else {\n        props.history.push(\"/404\");\n      }\n    }\n\n    // on UNMOUNTING (navigating to a different page) return this function\n    /** useEffect lets declare the code to run when a component UNMOUNTS\n     *  by returning a funciton.\n     */\n    return () => authorStore.removeChangeListener(onChange); // clean addChangeListener new page is rendered\n  }, [props.history, authors.length, props.match.params.id]); // declare a dependancy array\n  /** If anything in the dependency array changes, useEffect will re-run.\n   *  When useEffect runs the second time after authors are loaded\n   *  authors.length will not be 0 and if there's a id in the url\n   *  it will ask the store for the relevant author, and the author\n   *  will be there because the array of authors  has already been\n   *  populated in the Flux store.\n   */\n\n  // execute function when a author is added to the store\n  function onChange() {\n    // request authors from store and add/set to this component state\n    setAuthors(authorStore.getAuthors());\n    /** what this says is:\n     *  - getAuthors from the api\n     *  - when the api call completes, then\n     *  - store the array of authors in state */\n  }\n\n  // declare change handler for form inputs\n  function handleChange(event) {\n    /**\n     *  - use ...spread operator to copy state for editing\n     *  - set value passed in by form event based on the\n     *    name property of element e.g.\n     *    if attribute name=\"title\",\n     *    then value will be stored in author.title\n     *    and intialised to a variable prop [event.target.name]\n     *    called a Computed Property\n     *    which can be used by each form input.\n     *  - pass updated author to setauthor function*/\n    const updatedAuthor = {\n      ...author,\n      [event.target.name]: event.target.value,\n    };\n    setAuthor(updatedAuthor);\n  }\n\n  // form validation function\n  function formIsValid() {\n    // declare local errors object\n    const _errors = {};\n\n    // initialise errors if author props empty\n    if (!author.name) _errors.name = \"Name is required\";\n\n    // pass validation error result\n    setErrors(_errors);\n\n    // form is valid if the errors object has no properties\n    return Object.keys(_errors).length === 0; // returns boolean\n    /**\n     *  the Object.keys returns an array of an object's keys.\n     *  if the array of keys for the _errors' object is 0 then\n     *  the errors object has no properties.\n     */\n  }\n\n  // declare submit handler\n  // automatically receives an event from browser\n  function handleSubmit(event) {\n    // handle form validation\n    /** if the form is not valid then do nothing. */\n    if (!formIsValid()) return;\n\n    // to handle event on client, call prevent default post to server\n    event.preventDefault();\n\n    // call authorActions (instead of directly calling the api)\n    authorActions\n      // pass the author held in state\n      .saveAuthor(author)\n      /** all the api functions return a promise so we could\n       *  declare .then() to specify what should happen after\n       *  the saveAuthor is completed.\n       */\n      .then(() => {\n        // redirect back to AuthorsPage\n        props.history.push(\"/authors\");\n        /** since Add Author was loaded via\n         * React Router's Route we have access to\n         * React Router's history object on props.\n         * So we can programmatically redirect the\n         * user after the save is completed. */\n\n        // display notification after success save\n        toast.success(\"Author saved.\");\n      });\n  }\n\n  return (\n    <>\n      <h2>Manage Author</h2>\n      {/** Pass down to AuthorForm child component via props\n       *  - pass down author state object\n       *  - pass down change handler\n       *  - pass down save form handler\n       *  - pass down validation errors */}\n      <AuthorForm\n        author={author}\n        onChange={handleChange}\n        onSubmit={handleSubmit}\n        errors={errors}\n      />\n    </>\n  );\n};\n\nexport default ManageAuthorPage;\n\n// then create a route in App.js\n","import React from \"react\";\n\nimport { NavLink } from \"react-router-dom\";\n\n// create function component\nfunction Header() {\n  // declare styles for NavLinks\n  const activeStyle = { color: \"orange\" };\n  return (\n    <nav>\n      <NavLink activeStyle={activeStyle} exact to=\"/\">\n        Home\n      </NavLink>\n      {\" | \"}\n      <NavLink activeStyle={activeStyle} to=\"/courses\">\n        Courses\n      </NavLink>\n      {\" | \"}\n      <NavLink activeStyle={activeStyle} to=\"/authors\">\n        Authors\n      </NavLink>\n      {\" | \"}\n      <NavLink activeStyle={activeStyle} to=\"/about\">\n        About\n      </NavLink>\n    </nav>\n  );\n}\n\nexport default Header;\n","import React from \"react\";\nimport { Link } from \"react-router-dom\";\n\nfunction NotFoundPage() {\n  return (\n    <div>\n      <h2>Page Not Found</h2>\n      <p>\n        <Link to=\"/\">Back to home.</Link>\n      </p>\n    </div>\n  );\n}\n\nexport default NotFoundPage;\n","/** Route the pages based on the URL path */\n\nimport React from \"react\";\nimport HomePage from \"./HomePage\";\nimport AboutPage from \"./AboutPage\";\nimport CoursesPage from \"./CoursesPage\";\nimport AuthorsPage from \"./AuthorsPage\";\n\nimport ManageCoursePage from \"../components/ManageCoursePage\";\nimport ManageAuthorPage from \"../components/ManageAuthorPage\";\n\nimport { Route, Switch } from \"react-router-dom\";\n\nimport Header from \"../common/Header\";\nimport NotFoundPage from \"./NotFoundPage\";\n\n// configure toastify notifications\nimport { ToastContainer } from \"react-toastify\";\nimport \"react-toastify/dist/ReactToastify.css\";\n\n// declare function component\nfunction App() {\n  return (\n    <div className=\"container-fluid\">\n      {/** configure toastify container globally so we\n       *   can call it anywhere in our app.\n       */}\n      <ToastContainer\n        autoClose={3000} /** after 3 secs */\n        hideProgressBar /** is boolean, but omitting setting true infers truthiness */\n      />\n\n      {/** render header */}\n      <Header />\n      {/** declare application's routes\n       *  (Route component takes two props\n       *   1. the path which declares the URL to look for\n       *   2. the component it will load on match\n       *   The 'exact' keyword constrains the Route to an\n       *   an exact path match else any route with \"/\" will\n       *   be loaded)\n       */}\n      <Switch>\n        <Route path=\"/\" exact component={HomePage} />\n        <Route path=\"/courses\" exact component={CoursesPage} />\n        <Route path=\"/about\" exact component={AboutPage} />\n        <Route path=\"/course/:slug\" exact component={ManageCoursePage} />\n        <Route path=\"/course\" exact component={ManageCoursePage} />\n        <Route path=\"/authors\" exact component={AuthorsPage} />\n        <Route path=\"/author\" exact component={ManageAuthorPage} />\n        {/** when a path is not specified all routes\n         *   point to the declared component, unless\n         *   routes are wrapped inside a switch statement.\n         *   Inside a switch React-Route check the sequence\n         *   of routes and stops when a match is found. */}\n        <Route path=\"/404-Page-Not-Found\" component={NotFoundPage} />\n        <Route component={NotFoundPage} />\n      </Switch>\n    </div>\n  );\n}\n\n// export component\nexport default App;\n","import \"bootstrap/dist/css/bootstrap.min.css\";\nimport React from \"react\";\n\n/**\n *  creates a const named render that references\n *  react-dom's render function.\n *  Equivalent to:\n *  import ReactDOM from 'react-dom';\n *  const render = ReactDOM.render;\n *  React-dom renders apps for web browsers.\n */\nimport { render } from \"react-dom\";\n\n// import HomePage for rendering.\nimport App from \"./components/App\";\n\n// import react router library\nimport { BrowserRouter as Router } from \"react-router-dom\";\n\n// render app\nrender(\n  // wrap App with router to enable declaring routes in our components\n  <Router>\n    <App />\n  </Router>,\n  document.getElementById(\"root\")\n);\n"],"sourceRoot":""}