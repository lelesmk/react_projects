{"ast":null,"code":"import dispatcher from\"../appDispatcher\";// import authorApi to implement action calls to api\nimport*as authorApi from\"../api/authorApi\";import actionTypes from\"./actionTypes\";// ! the below function is called an Action Creator ! //\nexport function saveAuthor(author){// call authorApi to save a author passed in by this function\n/** return the promise from the call to api so\n   *  the caller of this function will be notified\n   *  when the promise resolves/completes */return authorApi.saveAuthor(author).then(function(savedAuthor){// returns savedAuthor\n// handle saved author response\n/** use flux dispatcher to notify all the stores\n     *  that a author was just created. Stores will\n     *  take the data payload dispatched here and\n     *  put it to use.\n     */dispatcher.dispatch(// an action is an object with actionType property\n{// ! the below properties declared make up the Action ! //\n// required property\n// actionType: \"CREATE_AUTHOR\",\n/**\n         *  actionType is hardcoded as a magic string.\n         *  this requires carefully typing it the\n         *  exact same way when declaring the store\n         *  which will handle the action.\n         *\n         *  instead its best practice to create a\n         *  constant file that contains a list of\n         *  all the actionTypes used in the system\n         *  (actionType is a constant so assigned\n         *  with uppercase.)\n         *\n         */ // call actionTypes object instead of hardcoding\n/** call action based on whether a we're working on\n         *  an existing author or new author.\n         */actionType:author.id// if author has an id\n?actionTypes.UPDATE_AUTHOR// then UPDATE\n:actionTypes.CREATE_AUTHOR,// else CREATE\n// optional properties to pass with action object\nauthor:savedAuthor});});}// declare flux call to api\nexport function loadAuthors(){return authorApi.getAuthors().then(function(authors){// returns authors array\n// dispatch authors array payload with action\ndispatcher.dispatch({actionType:actionTypes.LOAD_AUTHORS,authors:authors});});// Next, update the authorStore to handle this actionType\n}// get author by id\nexport function getAuthorById(id){return authorApi.getAuthorById(id).then(function(author){// empty return ()\n// dispatch authors array payload with action\ndispatcher.dispatch({actionType:actionTypes.GET_AUTHOR,author:author});});}// delete author by id\nexport function deleteAuthor(id){return authorApi.deleteAuthor(id).then(function(){// empty return ()\n// dispatch courses array payload with action\ndispatcher.dispatch({actionType:actionTypes.DELETE_AUTHOR,id:id});});}","map":{"version":3,"sources":["/Users/LelethuMkefa/dev/js-course/react-flux-app/src/actions/authorActions.js"],"names":["dispatcher","authorApi","actionTypes","saveAuthor","author","then","savedAuthor","dispatch","actionType","id","UPDATE_AUTHOR","CREATE_AUTHOR","loadAuthors","getAuthors","authors","LOAD_AUTHORS","getAuthorById","GET_AUTHOR","deleteAuthor","DELETE_AUTHOR"],"mappings":"AAAA,MAAOA,CAAAA,UAAP,KAAuB,kBAAvB,CAEA;AACA,MAAO,GAAKC,CAAAA,SAAZ,KAA2B,kBAA3B,CAEA,MAAOC,CAAAA,WAAP,KAAwB,eAAxB,CAEA;AACA,MAAO,SAASC,CAAAA,UAAT,CAAoBC,MAApB,CAA4B,CACjC;AACA;;4CAGA,MAAOH,CAAAA,SAAS,CAACE,UAAV,CAAqBC,MAArB,EAA6BC,IAA7B,CAAkC,SAACC,WAAD,CAAiB,CACxD;AACA;AACA;;;;OAKAN,UAAU,CAACO,QAAX,CACE;AACA,CACE;AAEA;AAEA;AACA;;;;;;;;;;;;WANF,CAoBE;AAEA;;WAGAC,UAAU,CAAEJ,MAAM,CAACK,EAAG;AAAV,CACRP,WAAW,CAACQ,aAAc;AADlB,CAERR,WAAW,CAACS,aA3BlB,CA2BiC;AAE/B;AACAP,MAAM,CAAEE,WA9BV,CAFF,EAmCD,CA3CM,CAAP,CA4CD,CAED;AACA,MAAO,SAASM,CAAAA,WAAT,EAAuB,CAC5B,MAAOX,CAAAA,SAAS,CAACY,UAAV,GAAuBR,IAAvB,CAA4B,SAACS,OAAD,CAAa,CAC9C;AACA;AACAd,UAAU,CAACO,QAAX,CAAoB,CAClBC,UAAU,CAAEN,WAAW,CAACa,YADN,CAElBD,OAAO,CAAEA,OAFS,CAApB,EAID,CAPM,CAAP,CASA;AACD,CAED;AACA,MAAO,SAASE,CAAAA,aAAT,CAAuBP,EAAvB,CAA2B,CAChC,MAAOR,CAAAA,SAAS,CAACe,aAAV,CAAwBP,EAAxB,EAA4BJ,IAA5B,CAAiC,SAACD,MAAD,CAAY,CAClD;AACA;AACAJ,UAAU,CAACO,QAAX,CAAoB,CAClBC,UAAU,CAAEN,WAAW,CAACe,UADN,CAElBb,MAAM,CAAEA,MAFU,CAApB,EAID,CAPM,CAAP,CAQD,CAED;AACA,MAAO,SAASc,CAAAA,YAAT,CAAsBT,EAAtB,CAA0B,CAC/B,MAAOR,CAAAA,SAAS,CAACiB,YAAV,CAAuBT,EAAvB,EAA2BJ,IAA3B,CAAgC,UAAM,CAC3C;AACA;AACAL,UAAU,CAACO,QAAX,CAAoB,CAClBC,UAAU,CAAEN,WAAW,CAACiB,aADN,CAElBV,EAAE,CAAEA,EAFc,CAApB,EAID,CAPM,CAAP,CAQD","sourcesContent":["import dispatcher from \"../appDispatcher\";\n\n// import authorApi to implement action calls to api\nimport * as authorApi from \"../api/authorApi\";\n\nimport actionTypes from \"./actionTypes\";\n\n// ! the below function is called an Action Creator ! //\nexport function saveAuthor(author) {\n  // call authorApi to save a author passed in by this function\n  /** return the promise from the call to api so\n   *  the caller of this function will be notified\n   *  when the promise resolves/completes */\n  return authorApi.saveAuthor(author).then((savedAuthor) => {\n    // returns savedAuthor\n    // handle saved author response\n    /** use flux dispatcher to notify all the stores\n     *  that a author was just created. Stores will\n     *  take the data payload dispatched here and\n     *  put it to use.\n     */\n    dispatcher.dispatch(\n      // an action is an object with actionType property\n      {\n        // ! the below properties declared make up the Action ! //\n\n        // required property\n\n        // actionType: \"CREATE_AUTHOR\",\n        /**\n         *  actionType is hardcoded as a magic string.\n         *  this requires carefully typing it the\n         *  exact same way when declaring the store\n         *  which will handle the action.\n         *\n         *  instead its best practice to create a\n         *  constant file that contains a list of\n         *  all the actionTypes used in the system\n         *  (actionType is a constant so assigned\n         *  with uppercase.)\n         *\n         */\n\n        // call actionTypes object instead of hardcoding\n\n        /** call action based on whether a we're working on\n         *  an existing author or new author.\n         */\n        actionType: author.id // if author has an id\n          ? actionTypes.UPDATE_AUTHOR // then UPDATE\n          : actionTypes.CREATE_AUTHOR, // else CREATE\n\n        // optional properties to pass with action object\n        author: savedAuthor,\n      }\n    );\n  });\n}\n\n// declare flux call to api\nexport function loadAuthors() {\n  return authorApi.getAuthors().then((authors) => {\n    // returns authors array\n    // dispatch authors array payload with action\n    dispatcher.dispatch({\n      actionType: actionTypes.LOAD_AUTHORS,\n      authors: authors,\n    });\n  });\n\n  // Next, update the authorStore to handle this actionType\n}\n\n// get author by id\nexport function getAuthorById(id) {\n  return authorApi.getAuthorById(id).then((author) => {\n    // empty return ()\n    // dispatch authors array payload with action\n    dispatcher.dispatch({\n      actionType: actionTypes.GET_AUTHOR,\n      author: author,\n    });\n  });\n}\n\n// delete author by id\nexport function deleteAuthor(id) {\n  return authorApi.deleteAuthor(id).then(() => {\n    // empty return ()\n    // dispatch courses array payload with action\n    dispatcher.dispatch({\n      actionType: actionTypes.DELETE_AUTHOR,\n      id: id,\n    });\n  });\n}\n"]},"metadata":{},"sourceType":"module"}