{"ast":null,"code":"import { EventEmitter } from \"events\";\nimport Dispatcher from \"../appDispatcher\"; // import actionTypes to bundle with the new course\n\nimport actionTypes from \"../actions/actionTypes\";\n/** store needs to emit an event each time\n *  a change occurs. Extend EventEmitter class\n *  to get this behaviour.\n *\n *  ! see node.js docs for events emitter methods. */\n// declare event constant to avoid hardcoding\n\nconst CHANGE_EVENT = \"change\"; // declare a private array to store course data\n\nlet _courses = [];\n/** course data is not exported/made public - only\n *  the store is exported. The only way to access\n *  the course data will be via public api which\n *  are the functions we declare in this module.\n *  So we can control how course data is managed.\n *\n *  Everytime a courseStore is created, the\n *  CREATE_COURSE action will be dispatched. It will\n *  include the new course as part of the payload.\n *\n *  So we want to take a new course that will be\n *  passed with the action and push it into an array\n *  that stores course data. This implementation is\n *  executed inside the code block where we register\n *  the store to the dispatcher.\n */\n\nclass CourseStore extends EventEmitter {\n  /**\n   *  the below methods provides a way for the UI/React\n   *  components to interact with the store.\n   *  every Flux store must have these 3 functions:\n   *  1. addChangeListener (wraps EventEmitter's 'on' method)\n   *  2. removeChangeListener (wraps EventEmitter's 'removeListener' method)\n   *  3. emitChange (wraps EventEmitter's 'emit' method)\n   */\n  // add listener function to listeners array for the event\n  addChangeListener(callback) {\n    // call on to watch for 'change' event\n    this.on(CHANGE_EVENT, // when change occurs we will call the callback function\n    callback);\n    /** this method will allow react components to subscribe\n     *  to the store to get notified when a chance occurs.\n     *  whatever callback function gets passed in will be\n     *  called anytime things change in the store.\n     */\n  } // remove specified listner from the listener array for the event\n\n\n  removeChangeListener(callback) {\n    this.removeListener(CHANGE_EVENT, callback);\n    /** this method will allow react components to unsubscribe\n     *  from the store.\n     */\n  } // synchronously calls each listener registered for the event, in order of register\n\n\n  emitChange() {\n    this.emit(CHANGE_EVENT);\n  } // give read access to private variable _courses\n\n\n  getCourses() {\n    return _courses;\n  } // find course by slug\n\n\n  getCourseBySlug(slug) {\n    // use JS find() method which accepts a boolean function (a 'predicate')\n\n    /** predicate anonymous function:\n     *  - look through this list of courses\n     *  - find the course that has slug equal to the slug passed in\n     */\n    return _courses.find(course => course.slug === slug);\n  } // TODO: Add other handy functions that searches course data\n\n\n} // instantiate class\n\n\nconst store = new CourseStore();\n/** dispatcher registration is private to the store\n *  thus defined below the store and not part of the\n *  public api.\n */\n\n/** register method accepts a function that takes in\n *  an action.\n *  this function will be called/notified of every\n *  single action dispatched.\n *  So we will need a function that switches based on\n *  the actionType that's being passed.\n */\n// register/subscribe to the dispatcher\n\nDispatcher.register(action => {\n  // based on action dispatched\n  switch (action.actionType) {\n    // create a new course and save it in a private store array\n    case actionTypes.CREATE_COURSE:\n      _courses.push(action.course);\n      /** action.course gets a course from the payload\n       *  dispatched by api functions in courseActions.js\n       *  action.actionType checked for in the switch\n       *  declaration gets the actionType from the same\n       *  dispatcher payload.\n       *  i.e. the action is dispatched in courseActions.js\n       *  by Dispatcher.dispatch() and caught here via\n       *  Dispatcher.register().\n       *\n       *  Remember the _course data is private so people\n       *  can't mess with it. We need a getCourses method\n       *  to access course data. Let's define it inside\n       *  the class (we are outside the class here) below\n       *  the emitChange() method.\n       *\n       */\n      // emit this change made to the store\n\n\n      store.emitChange();\n      /** emitting a change, will notify any component\n       *  registered with the store. The component will\n       *  know to update the UI accordingly.\n       *  More specifically, any store that calls\n       *  addChangeListener() method will be notified\n       *  every emitChange() is called.\n       */\n\n      break;\n\n    case actionTypes.LOAD_COURSES:\n      // load courses from payload in private store\n      _courses = action.courses; // anounce change to store\n\n      store.emitChange(); // Next, decide when to use this action\n\n      /** When do we want the full courses list to load?\n       *  1. When needed (Lazy loading data)?\n       *     - requires a check to see if courses have been loaded\n       *       on each page that needs course data.\n       *  2. When the app loads regardless of page user is on?\n       *     - if the app needs the same data on many pages, it\n       *       may be better to load the data immediately when the\n       *       app loads regardless of page.\n       */\n\n      break;\n\n    default: // nothing to do\n\n    /** Every store's dispatcher receives every action\n     *  dispatched, so if the store isn't interested in\n     *  that action, there's nothing to do.\n     */\n\n  }\n}); // export store\n\nexport default store;\n/** next, register store with dispatcher so\n *  the store is  notified when an action occurs.*/\n//====== BOILERPLATE CODE FOR STORES ====== //\n//========= The shell of a store ========= //\n\n/**\n *  1. Create a class that extends the EventEmitter\n *     to emit an event when an action produced\n *  2. Implement 3 EventEmitter functions to interact with UI\n *     (addChangeListener, removeChangeListener, emitChange)\n *  3. Create an instance of the store\n *  4. Register to the dispatcher so the store get's\n *     called/notified based on the actionType being passed.\n *  5. Implement the action (e.g. create courses and store),\n *     emit the changes, and create methods that access the data.\n *     The CourseStore holds the full list of courses now. React\n *     components/UI don't need to call the api directly to get\n *     course data. All they need to do is call store's methods.\n *\n *  NB! Redux a version of Flux avoids some of this\n *      implementation code. But this understanding makes\n *      it easier to learn Redux. Redux builds upon these\n *      principles.\n */","map":{"version":3,"sources":["/Users/LelethuMkefa/dev/js-course/react-flux-app/src/stores/courseStore.js"],"names":["EventEmitter","Dispatcher","actionTypes","CHANGE_EVENT","_courses","CourseStore","addChangeListener","callback","on","removeChangeListener","removeListener","emitChange","emit","getCourses","getCourseBySlug","slug","find","course","store","register","action","actionType","CREATE_COURSE","push","LOAD_COURSES","courses"],"mappings":"AAAA,SAASA,YAAT,QAA6B,QAA7B;AAEA,OAAOC,UAAP,MAAuB,kBAAvB,C,CAEA;;AACA,OAAOC,WAAP,MAAwB,wBAAxB;AAEA;;;;;AAMA;;AACA,MAAMC,YAAY,GAAG,QAArB,C,CAEA;;AACA,IAAIC,QAAQ,GAAG,EAAf;AACA;;;;;;;;;;;;;;;;;AAiBA,MAAMC,WAAN,SAA0BL,YAA1B,CAAuC;AACrC;;;;;;;;AAQA;AACAM,EAAAA,iBAAiB,CAACC,QAAD,EAAW;AAC1B;AACA,SAAKC,EAAL,CACEL,YADF,EAEE;AACAI,IAAAA,QAHF;AAKA;;;;;AAKD,GAtBoC,CAwBrC;;;AACAE,EAAAA,oBAAoB,CAACF,QAAD,EAAW;AAC7B,SAAKG,cAAL,CAAoBP,YAApB,EAAkCI,QAAlC;AACA;;;AAGD,GA9BoC,CA+BrC;;;AACAI,EAAAA,UAAU,GAAG;AACX,SAAKC,IAAL,CAAUT,YAAV;AACD,GAlCoC,CAoCrC;;;AACAU,EAAAA,UAAU,GAAG;AACX,WAAOT,QAAP;AACD,GAvCoC,CAyCrC;;;AACAU,EAAAA,eAAe,CAACC,IAAD,EAAO;AACpB;;AACA;;;;AAIA,WAAOX,QAAQ,CAACY,IAAT,CAAeC,MAAD,IAAYA,MAAM,CAACF,IAAP,KAAgBA,IAA1C,CAAP;AACD,GAjDoC,CAmDrC;;;AAnDqC,C,CAsDvC;;;AACA,MAAMG,KAAK,GAAG,IAAIb,WAAJ,EAAd;AAEA;;;;;AAKA;;;;;;;AAQA;;AACAJ,UAAU,CAACkB,QAAX,CAAqBC,MAAD,IAAY;AAC9B;AACA,UAAQA,MAAM,CAACC,UAAf;AACE;AACA,SAAKnB,WAAW,CAACoB,aAAjB;AACElB,MAAAA,QAAQ,CAACmB,IAAT,CAAcH,MAAM,CAACH,MAArB;AACA;;;;;;;;;;;;;;;;AAiBA;;;AACAC,MAAAA,KAAK,CAACP,UAAN;AACA;;;;;;;;AAOA;;AAEF,SAAKT,WAAW,CAACsB,YAAjB;AACE;AACApB,MAAAA,QAAQ,GAAGgB,MAAM,CAACK,OAAlB,CAFF,CAGE;;AACAP,MAAAA,KAAK,CAACP,UAAN,GAJF,CAKE;;AACA;;;;;;;;;;AASA;;AAEF,YAjDF,CAkDE;;AACA;;;;;AAnDF;AAwDD,CA1DD,E,CA4DA;;AACA,eAAeO,KAAf;AAEA;;AAGA;AACA;;AAEA","sourcesContent":["import { EventEmitter } from \"events\";\n\nimport Dispatcher from \"../appDispatcher\";\n\n// import actionTypes to bundle with the new course\nimport actionTypes from \"../actions/actionTypes\";\n\n/** store needs to emit an event each time\n *  a change occurs. Extend EventEmitter class\n *  to get this behaviour.\n *\n *  ! see node.js docs for events emitter methods. */\n\n// declare event constant to avoid hardcoding\nconst CHANGE_EVENT = \"change\";\n\n// declare a private array to store course data\nlet _courses = [];\n/** course data is not exported/made public - only\n *  the store is exported. The only way to access\n *  the course data will be via public api which\n *  are the functions we declare in this module.\n *  So we can control how course data is managed.\n *\n *  Everytime a courseStore is created, the\n *  CREATE_COURSE action will be dispatched. It will\n *  include the new course as part of the payload.\n *\n *  So we want to take a new course that will be\n *  passed with the action and push it into an array\n *  that stores course data. This implementation is\n *  executed inside the code block where we register\n *  the store to the dispatcher.\n */\n\nclass CourseStore extends EventEmitter {\n  /**\n   *  the below methods provides a way for the UI/React\n   *  components to interact with the store.\n   *  every Flux store must have these 3 functions:\n   *  1. addChangeListener (wraps EventEmitter's 'on' method)\n   *  2. removeChangeListener (wraps EventEmitter's 'removeListener' method)\n   *  3. emitChange (wraps EventEmitter's 'emit' method)\n   */\n  // add listener function to listeners array for the event\n  addChangeListener(callback) {\n    // call on to watch for 'change' event\n    this.on(\n      CHANGE_EVENT,\n      // when change occurs we will call the callback function\n      callback\n    );\n    /** this method will allow react components to subscribe\n     *  to the store to get notified when a chance occurs.\n     *  whatever callback function gets passed in will be\n     *  called anytime things change in the store.\n     */\n  }\n\n  // remove specified listner from the listener array for the event\n  removeChangeListener(callback) {\n    this.removeListener(CHANGE_EVENT, callback);\n    /** this method will allow react components to unsubscribe\n     *  from the store.\n     */\n  }\n  // synchronously calls each listener registered for the event, in order of register\n  emitChange() {\n    this.emit(CHANGE_EVENT);\n  }\n\n  // give read access to private variable _courses\n  getCourses() {\n    return _courses;\n  }\n\n  // find course by slug\n  getCourseBySlug(slug) {\n    // use JS find() method which accepts a boolean function (a 'predicate')\n    /** predicate anonymous function:\n     *  - look through this list of courses\n     *  - find the course that has slug equal to the slug passed in\n     */\n    return _courses.find((course) => course.slug === slug);\n  }\n\n  // TODO: Add other handy functions that searches course data\n}\n\n// instantiate class\nconst store = new CourseStore();\n\n/** dispatcher registration is private to the store\n *  thus defined below the store and not part of the\n *  public api.\n */\n\n/** register method accepts a function that takes in\n *  an action.\n *  this function will be called/notified of every\n *  single action dispatched.\n *  So we will need a function that switches based on\n *  the actionType that's being passed.\n */\n\n// register/subscribe to the dispatcher\nDispatcher.register((action) => {\n  // based on action dispatched\n  switch (action.actionType) {\n    // create a new course and save it in a private store array\n    case actionTypes.CREATE_COURSE:\n      _courses.push(action.course);\n      /** action.course gets a course from the payload\n       *  dispatched by api functions in courseActions.js\n       *  action.actionType checked for in the switch\n       *  declaration gets the actionType from the same\n       *  dispatcher payload.\n       *  i.e. the action is dispatched in courseActions.js\n       *  by Dispatcher.dispatch() and caught here via\n       *  Dispatcher.register().\n       *\n       *  Remember the _course data is private so people\n       *  can't mess with it. We need a getCourses method\n       *  to access course data. Let's define it inside\n       *  the class (we are outside the class here) below\n       *  the emitChange() method.\n       *\n       */\n\n      // emit this change made to the store\n      store.emitChange();\n      /** emitting a change, will notify any component\n       *  registered with the store. The component will\n       *  know to update the UI accordingly.\n       *  More specifically, any store that calls\n       *  addChangeListener() method will be notified\n       *  every emitChange() is called.\n       */\n      break;\n\n    case actionTypes.LOAD_COURSES:\n      // load courses from payload in private store\n      _courses = action.courses;\n      // anounce change to store\n      store.emitChange();\n      // Next, decide when to use this action\n      /** When do we want the full courses list to load?\n       *  1. When needed (Lazy loading data)?\n       *     - requires a check to see if courses have been loaded\n       *       on each page that needs course data.\n       *  2. When the app loads regardless of page user is on?\n       *     - if the app needs the same data on many pages, it\n       *       may be better to load the data immediately when the\n       *       app loads regardless of page.\n       */\n      break;\n\n    default:\n    // nothing to do\n    /** Every store's dispatcher receives every action\n     *  dispatched, so if the store isn't interested in\n     *  that action, there's nothing to do.\n     */\n  }\n});\n\n// export store\nexport default store;\n\n/** next, register store with dispatcher so\n *  the store is  notified when an action occurs.*/\n\n//====== BOILERPLATE CODE FOR STORES ====== //\n//========= The shell of a store ========= //\n\n/**\n *  1. Create a class that extends the EventEmitter\n *     to emit an event when an action produced\n *  2. Implement 3 EventEmitter functions to interact with UI\n *     (addChangeListener, removeChangeListener, emitChange)\n *  3. Create an instance of the store\n *  4. Register to the dispatcher so the store get's\n *     called/notified based on the actionType being passed.\n *  5. Implement the action (e.g. create courses and store),\n *     emit the changes, and create methods that access the data.\n *     The CourseStore holds the full list of courses now. React\n *     components/UI don't need to call the api directly to get\n *     course data. All they need to do is call store's methods.\n *\n *  NB! Redux a version of Flux avoids some of this\n *      implementation code. But this understanding makes\n *      it easier to learn Redux. Redux builds upon these\n *      principles.\n */\n"]},"metadata":{},"sourceType":"module"}