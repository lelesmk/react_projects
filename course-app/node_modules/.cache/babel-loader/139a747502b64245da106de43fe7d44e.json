{"ast":null,"code":"import { EventEmitter } from \"events\";\nimport Dispatcher from \"../appDispatcher\"; // import actionTypes to bundle with the new author\n\nimport actionTypes from \"../actions/actionTypes\";\n/** store needs to emit an event each time\n *  a change occurs. Extend EventEmitter class\n *  to get this behaviour.\n *\n *  ! see node.js docs for events emitter methods. */\n// declare event constant to avoid hardcoding\n\nconst CHANGE_EVENT = \"change\"; // declare a private array to store author data\n\nlet _authors = [];\n/** author data is not exported/made public - only\n *  the store is exported. The only way to access\n *  the author data will be via public api which\n *  are the functions we declare in this module.\n *  So we can control how AUTHOR data is managed.\n *\n *  Everytime a authorStore is created, the\n *  CREATE_AUTHOR action will be dispatched. It will\n *  include the new author as part of the payload.\n *\n *  So we want to take a new author that will be\n *  passed with the action and push it into an array\n *  that stores author data. This implementation is\n *  executed inside the code block where we register\n *  the store to the dispatcher.\n */\n\nclass AuthorStore extends EventEmitter {\n  /**\n   *  the below methods provides a way for the UI/React\n   *  components to interact with the store.\n   *  every Flux store must have these 3 functions:\n   *  1. addChangeListener (wraps EventEmitter's 'on' method)\n   *  2. removeChangeListener (wraps EventEmitter's 'removeListener' method)\n   *  3. emitChange (wraps EventEmitter's 'emit' method)\n   */\n  // add listener function to listeners array for the event\n  addChangeListener(callback) {\n    // call on to watch for 'change' event\n    this.on(CHANGE_EVENT, // when change occurs we will call the callback function\n    callback);\n    /** this method will allow react components to subscribe\n     *  to the store to get notified when a chance occurs.\n     *  whatever callback function gets passed in will be\n     *  called anytime things change in the store.\n     */\n  } // remove specified listner from the listener array for the event\n\n\n  removeChangeListener(callback) {\n    this.removeListener(CHANGE_EVENT, callback);\n    /** this method will allow react components to unsubscribe\n     *  from the store.\n     */\n  } // synchronously calls each listener registered for the event, in order of register\n\n\n  emitChange() {\n    this.emit(CHANGE_EVENT);\n  } // give read access to private variable _authors\n\n\n  getAuthors() {\n    return _authors;\n  } // find author by id\n\n\n  getAuthorById(id) {\n    // use JS find() method which accepts a boolean function (a 'predicate')\n\n    /** predicate anonymous function:\n     *  - look through this list of _authors\n     *  - find the author that has id equal to the id passed in\n     */\n    return _authors.find(author => author.id === id);\n  } // redirect if author not found\n\n\n  authorFound(id) {\n    // search for authors that match the id\n    if (_authors.filter(author => author.id === id).length > 0) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n} // instantiate class\n\n\nconst authorStore = new AuthorStore();\n/** dispatcher registration is private to the store\n *  thus defined below the store and not part of the\n *  public api.\n */\n\n/** register method accepts a function that takes in\n *  an action.\n *  this function will be called/notified of every\n *  single action dispatched.\n *  So we will need a function that switches based on\n *  the actionType that's being passed.\n */\n// Register/subscribe to the dispatcher\n\nDispatcher.register(payload => {\n  // based on action dispatched\n  switch (payload.actionType) {\n    // create a new author and save it in a private store array\n    case actionTypes.CREATE_AUTHOR:\n      _authors.push(payload.author);\n      /** action.author gets a author from the payload\n       *  dispatched by api functions in authorActions.js\n       *  action.actionType checked for in the switch\n       *  declaration gets the actionType from the same\n       *  dispatcher payload.\n       *  i.e. the action is dispatched in authorActions.js\n       *  by Dispatcher.dispatch() and caught here via\n       *  Dispatcher.register().\n       *\n       *  Remember the _author data is private so people\n       *  can't mess with it. We need a getAuthors method\n       *  to access author data. Let's define it inside\n       *  the class (we are outside the class here) below\n       *  the emitChange() method.\n       *\n       */\n      // emit this change made to the store\n\n\n      authorStore.emitChange();\n      /** emitting a change, will notify any component\n       *  registered with the store. The component will\n       *  know to update the UI accordingly.\n       *  More specifically, any store that calls\n       *  addChangeListener() method will be notified\n       *  every emitChange() is called.\n       */\n\n      break;\n\n    case actionTypes.LOAD_COURSES:\n      // load authors from payload in private store\n      _authors = payload.authors; // anounce change to store\n\n      authorStore.emitChange(); // Next, decide when to use this action and update AuthorsPage\n\n      /** When do we want the full authors list to load?\n       *  1. When needed (Lazy loading data)?\n       *     - requires a check to see if authors have been loaded\n       *       on each page that needs author data.\n       *\n       *  2. When the app loads regardless of page user is on?\n       *     - if the app needs the same data on many pages, it\n       *       may be better to load the data immediately when the\n       *       app loads regardless of page.\n       *\n       *  (For this app we'll implement lazy loading for learning.)\n       */\n\n      break;\n\n    case actionTypes.UPDATE_AUTHOR:\n      /**\n       *  Map over the _authors array and replace the author we want to update.\n       *  (map creates a new array by iterating an existing array.\n       *  we specify what value to put in the new array for each\n       *  element currently in the array.)\n       *  - update private array of authors by mapping over the existing array\n       *  - for each author check if author.id is equal to the action.author.id\n       *  - if true, replace that author with the action.author\n       *  - else leave as is\n       */\n      _authors = _authors.map(author => author.id === payload.author.id ? payload.author : author);\n      authorStore.emitChange();\n      break;\n    // delete author\n\n    case actionTypes.DELETE_AUTHOR:\n      _authors = _authors.filter(\n      /** for each author in _authors, check if author.id equals action.id (parse to Int possible string\n       *  and set radix to base 10)\n       *  if function returns true, filter out the match that was deleted.\n       *  this will return a new array of authors with one less author.\n       */\n      author => author.id !== parseInt(payload.id, 10) // for filter we pass it a boolean function (a predicate)\n      );\n      authorStore.emitChange(); // Next, implement the UI\n\n      break;\n\n    default: // nothing to do\n\n    /** Every store's dispatcher receives every action\n     *  dispatched, so if the store isn't interested in\n     *  that action, there's nothing to do.\n     */\n\n  }\n}); // export store\n\nexport default authorStore;","map":{"version":3,"sources":["/Users/LelethuMkefa/dev/js-course/react-flux-app/src/stores/authorStore.js"],"names":["EventEmitter","Dispatcher","actionTypes","CHANGE_EVENT","_authors","AuthorStore","addChangeListener","callback","on","removeChangeListener","removeListener","emitChange","emit","getAuthors","getAuthorById","id","find","author","authorFound","filter","length","authorStore","register","payload","actionType","CREATE_AUTHOR","push","LOAD_COURSES","authors","UPDATE_AUTHOR","map","DELETE_AUTHOR","parseInt"],"mappings":"AAAA,SAASA,YAAT,QAA6B,QAA7B;AAEA,OAAOC,UAAP,MAAuB,kBAAvB,C,CAEA;;AACA,OAAOC,WAAP,MAAwB,wBAAxB;AAEA;;;;;AAMA;;AACA,MAAMC,YAAY,GAAG,QAArB,C,CAEA;;AACA,IAAIC,QAAQ,GAAG,EAAf;AACA;;;;;;;;;;;;;;;;;AAiBA,MAAMC,WAAN,SAA0BL,YAA1B,CAAuC;AACrC;;;;;;;;AAQA;AACAM,EAAAA,iBAAiB,CAACC,QAAD,EAAW;AAC1B;AACA,SAAKC,EAAL,CACEL,YADF,EAEE;AACAI,IAAAA,QAHF;AAKA;;;;;AAKD,GAtBoC,CAwBrC;;;AACAE,EAAAA,oBAAoB,CAACF,QAAD,EAAW;AAC7B,SAAKG,cAAL,CAAoBP,YAApB,EAAkCI,QAAlC;AACA;;;AAGD,GA9BoC,CA+BrC;;;AACAI,EAAAA,UAAU,GAAG;AACX,SAAKC,IAAL,CAAUT,YAAV;AACD,GAlCoC,CAoCrC;;;AACAU,EAAAA,UAAU,GAAG;AACX,WAAOT,QAAP;AACD,GAvCoC,CAyCrC;;;AACAU,EAAAA,aAAa,CAACC,EAAD,EAAK;AAChB;;AACA;;;;AAKA,WAAOX,QAAQ,CAACY,IAAT,CAAeC,MAAD,IAAYA,MAAM,CAACF,EAAP,KAAcA,EAAxC,CAAP;AACD,GAlDoC,CAoDrC;;;AACAG,EAAAA,WAAW,CAACH,EAAD,EAAK;AACd;AACA,QAAIX,QAAQ,CAACe,MAAT,CAAiBF,MAAD,IAAYA,MAAM,CAACF,EAAP,KAAcA,EAA1C,EAA8CK,MAA9C,GAAuD,CAA3D,EAA8D;AAC5D,aAAO,IAAP;AACD,KAFD,MAEO;AACL,aAAO,KAAP;AACD;AACF;;AA5DoC,C,CA+DvC;;;AACA,MAAMC,WAAW,GAAG,IAAIhB,WAAJ,EAApB;AAEA;;;;;AAKA;;;;;;;AAQA;;AACAJ,UAAU,CAACqB,QAAX,CAAqBC,OAAD,IAAa;AAC/B;AACA,UAAQA,OAAO,CAACC,UAAhB;AACE;AACA,SAAKtB,WAAW,CAACuB,aAAjB;AACErB,MAAAA,QAAQ,CAACsB,IAAT,CAAcH,OAAO,CAACN,MAAtB;AACA;;;;;;;;;;;;;;;;AAiBA;;;AACAI,MAAAA,WAAW,CAACV,UAAZ;AACA;;;;;;;;AAOA;;AAEF,SAAKT,WAAW,CAACyB,YAAjB;AACE;AACAvB,MAAAA,QAAQ,GAAGmB,OAAO,CAACK,OAAnB,CAFF,CAGE;;AACAP,MAAAA,WAAW,CAACV,UAAZ,GAJF,CAKE;;AACA;;;;;;;;;;;;;AAYA;;AAEF,SAAKT,WAAW,CAAC2B,aAAjB;AACE;;;;;;;;;;AAUAzB,MAAAA,QAAQ,GAAGA,QAAQ,CAAC0B,GAAT,CAAcb,MAAD,IACtBA,MAAM,CAACF,EAAP,KAAcQ,OAAO,CAACN,MAAR,CAAeF,EAA7B,GAAkCQ,OAAO,CAACN,MAA1C,GAAmDA,MAD1C,CAAX;AAIAI,MAAAA,WAAW,CAACV,UAAZ;AACA;AAEF;;AACA,SAAKT,WAAW,CAAC6B,aAAjB;AACE3B,MAAAA,QAAQ,GAAGA,QAAQ,CAACe,MAAT;AACT;;;;;AAKCF,MAAAA,MAAD,IAAYA,MAAM,CAACF,EAAP,KAAciB,QAAQ,CAACT,OAAO,CAACR,EAAT,EAAa,EAAb,CANzB,CAM0C;AAN1C,OAAX;AAQAM,MAAAA,WAAW,CAACV,UAAZ,GATF,CAUE;;AACA;;AAEF,YApFF,CAqFE;;AACA;;;;;AAtFF;AA2FD,CA7FD,E,CA+FA;;AACA,eAAeU,WAAf","sourcesContent":["import { EventEmitter } from \"events\";\n\nimport Dispatcher from \"../appDispatcher\";\n\n// import actionTypes to bundle with the new author\nimport actionTypes from \"../actions/actionTypes\";\n\n/** store needs to emit an event each time\n *  a change occurs. Extend EventEmitter class\n *  to get this behaviour.\n *\n *  ! see node.js docs for events emitter methods. */\n\n// declare event constant to avoid hardcoding\nconst CHANGE_EVENT = \"change\";\n\n// declare a private array to store author data\nlet _authors = [];\n/** author data is not exported/made public - only\n *  the store is exported. The only way to access\n *  the author data will be via public api which\n *  are the functions we declare in this module.\n *  So we can control how AUTHOR data is managed.\n *\n *  Everytime a authorStore is created, the\n *  CREATE_AUTHOR action will be dispatched. It will\n *  include the new author as part of the payload.\n *\n *  So we want to take a new author that will be\n *  passed with the action and push it into an array\n *  that stores author data. This implementation is\n *  executed inside the code block where we register\n *  the store to the dispatcher.\n */\n\nclass AuthorStore extends EventEmitter {\n  /**\n   *  the below methods provides a way for the UI/React\n   *  components to interact with the store.\n   *  every Flux store must have these 3 functions:\n   *  1. addChangeListener (wraps EventEmitter's 'on' method)\n   *  2. removeChangeListener (wraps EventEmitter's 'removeListener' method)\n   *  3. emitChange (wraps EventEmitter's 'emit' method)\n   */\n  // add listener function to listeners array for the event\n  addChangeListener(callback) {\n    // call on to watch for 'change' event\n    this.on(\n      CHANGE_EVENT,\n      // when change occurs we will call the callback function\n      callback\n    );\n    /** this method will allow react components to subscribe\n     *  to the store to get notified when a chance occurs.\n     *  whatever callback function gets passed in will be\n     *  called anytime things change in the store.\n     */\n  }\n\n  // remove specified listner from the listener array for the event\n  removeChangeListener(callback) {\n    this.removeListener(CHANGE_EVENT, callback);\n    /** this method will allow react components to unsubscribe\n     *  from the store.\n     */\n  }\n  // synchronously calls each listener registered for the event, in order of register\n  emitChange() {\n    this.emit(CHANGE_EVENT);\n  }\n\n  // give read access to private variable _authors\n  getAuthors() {\n    return _authors;\n  }\n\n  // find author by id\n  getAuthorById(id) {\n    // use JS find() method which accepts a boolean function (a 'predicate')\n    /** predicate anonymous function:\n     *  - look through this list of _authors\n     *  - find the author that has id equal to the id passed in\n     */\n\n    return _authors.find((author) => author.id === id);\n  }\n\n  // redirect if author not found\n  authorFound(id) {\n    // search for authors that match the id\n    if (_authors.filter((author) => author.id === id).length > 0) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n}\n\n// instantiate class\nconst authorStore = new AuthorStore();\n\n/** dispatcher registration is private to the store\n *  thus defined below the store and not part of the\n *  public api.\n */\n\n/** register method accepts a function that takes in\n *  an action.\n *  this function will be called/notified of every\n *  single action dispatched.\n *  So we will need a function that switches based on\n *  the actionType that's being passed.\n */\n\n// Register/subscribe to the dispatcher\nDispatcher.register((payload) => {\n  // based on action dispatched\n  switch (payload.actionType) {\n    // create a new author and save it in a private store array\n    case actionTypes.CREATE_AUTHOR:\n      _authors.push(payload.author);\n      /** action.author gets a author from the payload\n       *  dispatched by api functions in authorActions.js\n       *  action.actionType checked for in the switch\n       *  declaration gets the actionType from the same\n       *  dispatcher payload.\n       *  i.e. the action is dispatched in authorActions.js\n       *  by Dispatcher.dispatch() and caught here via\n       *  Dispatcher.register().\n       *\n       *  Remember the _author data is private so people\n       *  can't mess with it. We need a getAuthors method\n       *  to access author data. Let's define it inside\n       *  the class (we are outside the class here) below\n       *  the emitChange() method.\n       *\n       */\n\n      // emit this change made to the store\n      authorStore.emitChange();\n      /** emitting a change, will notify any component\n       *  registered with the store. The component will\n       *  know to update the UI accordingly.\n       *  More specifically, any store that calls\n       *  addChangeListener() method will be notified\n       *  every emitChange() is called.\n       */\n      break;\n\n    case actionTypes.LOAD_COURSES:\n      // load authors from payload in private store\n      _authors = payload.authors;\n      // anounce change to store\n      authorStore.emitChange();\n      // Next, decide when to use this action and update AuthorsPage\n      /** When do we want the full authors list to load?\n       *  1. When needed (Lazy loading data)?\n       *     - requires a check to see if authors have been loaded\n       *       on each page that needs author data.\n       *\n       *  2. When the app loads regardless of page user is on?\n       *     - if the app needs the same data on many pages, it\n       *       may be better to load the data immediately when the\n       *       app loads regardless of page.\n       *\n       *  (For this app we'll implement lazy loading for learning.)\n       */\n      break;\n\n    case actionTypes.UPDATE_AUTHOR:\n      /**\n       *  Map over the _authors array and replace the author we want to update.\n       *  (map creates a new array by iterating an existing array.\n       *  we specify what value to put in the new array for each\n       *  element currently in the array.)\n       *  - update private array of authors by mapping over the existing array\n       *  - for each author check if author.id is equal to the action.author.id\n       *  - if true, replace that author with the action.author\n       *  - else leave as is\n       */\n      _authors = _authors.map((author) =>\n        author.id === payload.author.id ? payload.author : author\n      );\n\n      authorStore.emitChange();\n      break;\n\n    // delete author\n    case actionTypes.DELETE_AUTHOR:\n      _authors = _authors.filter(\n        /** for each author in _authors, check if author.id equals action.id (parse to Int possible string\n         *  and set radix to base 10)\n         *  if function returns true, filter out the match that was deleted.\n         *  this will return a new array of authors with one less author.\n         */\n        (author) => author.id !== parseInt(payload.id, 10) // for filter we pass it a boolean function (a predicate)\n      );\n      authorStore.emitChange();\n      // Next, implement the UI\n      break;\n\n    default:\n    // nothing to do\n    /** Every store's dispatcher receives every action\n     *  dispatched, so if the store isn't interested in\n     *  that action, there's nothing to do.\n     */\n  }\n});\n\n// export store\nexport default authorStore;\n"]},"metadata":{},"sourceType":"module"}