{"ast":null,"code":"import _classCallCheck from\"/Users/LelethuMkefa/dev/js-course/course-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";import _createClass from\"/Users/LelethuMkefa/dev/js-course/course-app/node_modules/@babel/runtime/helpers/esm/createClass\";import _inherits from\"/Users/LelethuMkefa/dev/js-course/course-app/node_modules/@babel/runtime/helpers/esm/inherits\";import _createSuper from\"/Users/LelethuMkefa/dev/js-course/course-app/node_modules/@babel/runtime/helpers/esm/createSuper\";import{EventEmitter}from\"events\";import Dispatcher from\"../appDispatcher\";// import actionTypes to bundle with the new author\nimport actionTypes from\"../actions/actionTypes\";/** store needs to emit an event each time\n *  a change occurs. Extend EventEmitter class\n *  to get this behaviour.\n *\n *  ! see node.js docs for events emitter methods. */ // declare event constant to avoid hardcoding\nvar CHANGE_EVENT=\"change\";// declare a private array to store author data\nvar _authors=[];/** author data is not exported/made public - only\n *  the store is exported. The only way to access\n *  the author data will be via public api which\n *  are the functions we declare in this module.\n *  So we can control how AUTHOR data is managed.\n *\n *  Everytime a authorStore is created, the\n *  CREATE_AUTHOR action will be dispatched. It will\n *  include the new author as part of the payload.\n *\n *  So we want to take a new author that will be\n *  passed with the action and push it into an array\n *  that stores author data. This implementation is\n *  executed inside the code block where we register\n *  the store to the dispatcher.\n */var AuthorStore=/*#__PURE__*/function(_EventEmitter){_inherits(AuthorStore,_EventEmitter);var _super=_createSuper(AuthorStore);function AuthorStore(){_classCallCheck(this,AuthorStore);return _super.apply(this,arguments);}_createClass(AuthorStore,[{key:\"addChangeListener\",/**\n   *  the below methods provides a way for the UI/React\n   *  components to interact with the store.\n   *  every Flux store must have these 3 functions:\n   *  1. addChangeListener (wraps EventEmitter's 'on' method)\n   *  2. removeChangeListener (wraps EventEmitter's 'removeListener' method)\n   *  3. emitChange (wraps EventEmitter's 'emit' method)\n   */ // add listener function to listeners array for the event\nvalue:function addChangeListener(callback){// call on to watch for 'change' event\nthis.on(CHANGE_EVENT,// when change occurs we will call the callback function\ncallback);/** this method will allow react components to subscribe\n     *  to the store to get notified when a chance occurs.\n     *  whatever callback function gets passed in will be\n     *  called anytime things change in the store.\n     */}// remove specified listner from the listener array for the event\n},{key:\"removeChangeListener\",value:function removeChangeListener(callback){this.removeListener(CHANGE_EVENT,callback);/** this method will allow react components to unsubscribe\n     *  from the store.\n     */}// synchronously calls each listener registered for the event, in order of register\n},{key:\"emitChange\",value:function emitChange(){this.emit(CHANGE_EVENT);}// give read access to private variable _authors\n},{key:\"getAuthors\",value:function getAuthors(){return _authors;}// find author by id\n},{key:\"getAuthorById\",value:function getAuthorById(id){// use JS find() method which accepts a boolean function (a 'predicate')\n/** predicate anonymous function:\n     *  - look through this list of _authors\n     *  - find the author that has id equal to the id passed in\n     */return _authors.find(function(author){return author.id===id;});}// redirect if author not found\n},{key:\"authorFound\",value:function authorFound(id){// search for authors that match the id\nif(_authors.filter(function(author){return author.id===id;}).length>0){return true;}else{return false;}}}]);return AuthorStore;}(EventEmitter);// instantiate class\nvar authorStore=new AuthorStore();/** dispatcher registration is private to the store\n *  thus defined below the store and not part of the\n *  public api.\n */ /** register method accepts a function that takes in\n *  an action.\n *  this function will be called/notified of every\n *  single action dispatched.\n *  So we will need a function that switches based on\n *  the actionType that's being passed.\n */ // Register/subscribe to the dispatcher\nDispatcher.register(function(payload){// based on action dispatched\nswitch(payload.actionType){// create a new author and save it in a private store array\ncase actionTypes.CREATE_AUTHOR:_authors.push(payload.author);/** action.author gets a author from the payload\n       *  dispatched by api functions in authorActions.js\n       *  action.actionType checked for in the switch\n       *  declaration gets the actionType from the same\n       *  dispatcher payload.\n       *  i.e. the action is dispatched in authorActions.js\n       *  by Dispatcher.dispatch() and caught here via\n       *  Dispatcher.register().\n       *\n       *  Remember the _author data is private so people\n       *  can't mess with it. We need a getAuthors method\n       *  to access author data. Let's define it inside\n       *  the class (we are outside the class here) below\n       *  the emitChange() method.\n       *\n       */ // emit this change made to the store\nauthorStore.emitChange();/** emitting a change, will notify any component\n       *  registered with the store. The component will\n       *  know to update the UI accordingly.\n       *  More specifically, any store that calls\n       *  addChangeListener() method will be notified\n       *  every emitChange() is called.\n       */break;case actionTypes.GET_AUTHOR:_authors=payload.author;authorStore.emitChange();break;case actionTypes.LOAD_AUTHORS:// load authors from payload in private store\n_authors=payload.authors;// anounce change to store\nauthorStore.emitChange();// Next, decide when to use this action and update AuthorsPage\n/** When do we want the full authors list to load?\n       *  1. When needed (Lazy loading data)?\n       *     - requires a check to see if authors have been loaded\n       *       on each page that needs author data.\n       *\n       *  2. When the app loads regardless of page user is on?\n       *     - if the app needs the same data on many pages, it\n       *       may be better to load the data immediately when the\n       *       app loads regardless of page.\n       *\n       *  (For this app we'll implement lazy loading for learning.)\n       */break;case actionTypes.UPDATE_AUTHOR:/**\n       *  Map over the _authors array and replace the author we want to update.\n       *  (map creates a new array by iterating an existing array.\n       *  we specify what value to put in the new array for each\n       *  element currently in the array.)\n       *  - update private array of authors by mapping over the existing array\n       *  - for each author check if author.id is equal to the action.author.id\n       *  - if true, replace that author with the action.author\n       *  - else leave as is\n       */_authors=_authors.map(function(author){return author.id===payload.author.id?payload.author:author;});authorStore.emitChange();break;// delete author\ncase actionTypes.DELETE_AUTHOR:_authors=_authors.filter(/** for each author in _authors, check if author.id equals action.id (parse to Int possible string\n         *  and set radix to base 10)\n         *  if function returns true, filter out the match that was deleted.\n         *  this will return a new array of authors with one less author.\n         */function(author){return author.id!==parseInt(payload.id,10);}// for filter we pass it a boolean function (a predicate)\n);authorStore.emitChange();// Next, implement the UI\nbreak;default:// nothing to do\n/** Every store's dispatcher receives every action\n     *  dispatched, so if the store isn't interested in\n     *  that action, there's nothing to do.\n     */}});// export store\nexport default authorStore;","map":{"version":3,"sources":["/Users/LelethuMkefa/dev/js-course/course-app/src/stores/authorStore.js"],"names":["EventEmitter","Dispatcher","actionTypes","CHANGE_EVENT","_authors","AuthorStore","callback","on","removeListener","emit","id","find","author","filter","length","authorStore","register","payload","actionType","CREATE_AUTHOR","push","emitChange","GET_AUTHOR","LOAD_AUTHORS","authors","UPDATE_AUTHOR","map","DELETE_AUTHOR","parseInt"],"mappings":"4eAAA,OAASA,YAAT,KAA6B,QAA7B,CAEA,MAAOC,CAAAA,UAAP,KAAuB,kBAAvB,CAEA;AACA,MAAOC,CAAAA,WAAP,KAAwB,wBAAxB,CAEA;;;;sDAMA;AACA,GAAMC,CAAAA,YAAY,CAAG,QAArB,CAEA;AACA,GAAIC,CAAAA,QAAQ,CAAG,EAAf,CAEA;;;;;;;;;;;;;;;MAiBMC,CAAAA,W,iQACJ;;;;;;;MAQA;iCACkBC,Q,CAAU,CAC1B;AACA,KAAKC,EAAL,CACEJ,YADF,CAEE;AACAG,QAHF,EAKA;;;;OAKD,CAED;kEACqBA,Q,CAAU,CAC7B,KAAKE,cAAL,CAAoBL,YAApB,CAAkCG,QAAlC,EACA;;OAGD,CACD;+CACa,CACX,KAAKG,IAAL,CAAUN,YAAV,EACD,CAED;+CACa,CACX,MAAOC,CAAAA,QAAP,CACD,CAED;oDACcM,E,CAAI,CAChB;AACA;;;OAKA,MAAON,CAAAA,QAAQ,CAACO,IAAT,CAAc,SAACC,MAAD,QAAYA,CAAAA,MAAM,CAACF,EAAP,GAAcA,EAA1B,EAAd,CAAP,CACD,CAED;gDACYA,E,CAAI,CACd;AACA,GAAIN,QAAQ,CAACS,MAAT,CAAgB,SAACD,MAAD,QAAYA,CAAAA,MAAM,CAACF,EAAP,GAAcA,EAA1B,EAAhB,EAA8CI,MAA9C,CAAuD,CAA3D,CAA8D,CAC5D,MAAO,KAAP,CACD,CAFD,IAEO,CACL,MAAO,MAAP,CACD,CACF,C,yBA5DuBd,Y,EA+D1B;AACA,GAAMe,CAAAA,WAAW,CAAG,GAAIV,CAAAA,WAAJ,EAApB,CAEA;;;IAKA;;;;;;IAQA;AACAJ,UAAU,CAACe,QAAX,CAAoB,SAACC,OAAD,CAAa,CAC/B;AACA,OAAQA,OAAO,CAACC,UAAhB,EACE;AACA,IAAKhB,CAAAA,WAAW,CAACiB,aAAjB,CACEf,QAAQ,CAACgB,IAAT,CAAcH,OAAO,CAACL,MAAtB,EACA;;;;;;;;;;;;;;;SAFF,CAmBE;AACAG,WAAW,CAACM,UAAZ,GACA;;;;;;SAOA,MAEF,IAAKnB,CAAAA,WAAW,CAACoB,UAAjB,CACElB,QAAQ,CAAGa,OAAO,CAACL,MAAnB,CACAG,WAAW,CAACM,UAAZ,GACA,MAEF,IAAKnB,CAAAA,WAAW,CAACqB,YAAjB,CACE;AACAnB,QAAQ,CAAGa,OAAO,CAACO,OAAnB,CACA;AACAT,WAAW,CAACM,UAAZ,GACA;AACA;;;;;;;;;;;SAYA,MAEF,IAAKnB,CAAAA,WAAW,CAACuB,aAAjB,CACE;;;;;;;;;SAUArB,QAAQ,CAAGA,QAAQ,CAACsB,GAAT,CAAa,SAACd,MAAD,QACtBA,CAAAA,MAAM,CAACF,EAAP,GAAcO,OAAO,CAACL,MAAR,CAAeF,EAA7B,CAAkCO,OAAO,CAACL,MAA1C,CAAmDA,MAD7B,EAAb,CAAX,CAIAG,WAAW,CAACM,UAAZ,GACA,MAEF;AACA,IAAKnB,CAAAA,WAAW,CAACyB,aAAjB,CACEvB,QAAQ,CAAGA,QAAQ,CAACS,MAAT,CACT;;;;WAKA,SAACD,MAAD,QAAYA,CAAAA,MAAM,CAACF,EAAP,GAAckB,QAAQ,CAACX,OAAO,CAACP,EAAT,CAAa,EAAb,CAAlC,EAAmD;AAN1C,CAAX,CAQAK,WAAW,CAACM,UAAZ,GACA;AACA,MAEF,QACA;AACA;;;OA3FF,CAgGD,CAlGD,EAoGA;AACA,cAAeN,CAAAA,WAAf","sourcesContent":["import { EventEmitter } from \"events\";\n\nimport Dispatcher from \"../appDispatcher\";\n\n// import actionTypes to bundle with the new author\nimport actionTypes from \"../actions/actionTypes\";\n\n/** store needs to emit an event each time\n *  a change occurs. Extend EventEmitter class\n *  to get this behaviour.\n *\n *  ! see node.js docs for events emitter methods. */\n\n// declare event constant to avoid hardcoding\nconst CHANGE_EVENT = \"change\";\n\n// declare a private array to store author data\nlet _authors = [];\n\n/** author data is not exported/made public - only\n *  the store is exported. The only way to access\n *  the author data will be via public api which\n *  are the functions we declare in this module.\n *  So we can control how AUTHOR data is managed.\n *\n *  Everytime a authorStore is created, the\n *  CREATE_AUTHOR action will be dispatched. It will\n *  include the new author as part of the payload.\n *\n *  So we want to take a new author that will be\n *  passed with the action and push it into an array\n *  that stores author data. This implementation is\n *  executed inside the code block where we register\n *  the store to the dispatcher.\n */\n\nclass AuthorStore extends EventEmitter {\n  /**\n   *  the below methods provides a way for the UI/React\n   *  components to interact with the store.\n   *  every Flux store must have these 3 functions:\n   *  1. addChangeListener (wraps EventEmitter's 'on' method)\n   *  2. removeChangeListener (wraps EventEmitter's 'removeListener' method)\n   *  3. emitChange (wraps EventEmitter's 'emit' method)\n   */\n  // add listener function to listeners array for the event\n  addChangeListener(callback) {\n    // call on to watch for 'change' event\n    this.on(\n      CHANGE_EVENT,\n      // when change occurs we will call the callback function\n      callback\n    );\n    /** this method will allow react components to subscribe\n     *  to the store to get notified when a chance occurs.\n     *  whatever callback function gets passed in will be\n     *  called anytime things change in the store.\n     */\n  }\n\n  // remove specified listner from the listener array for the event\n  removeChangeListener(callback) {\n    this.removeListener(CHANGE_EVENT, callback);\n    /** this method will allow react components to unsubscribe\n     *  from the store.\n     */\n  }\n  // synchronously calls each listener registered for the event, in order of register\n  emitChange() {\n    this.emit(CHANGE_EVENT);\n  }\n\n  // give read access to private variable _authors\n  getAuthors() {\n    return _authors;\n  }\n\n  // find author by id\n  getAuthorById(id) {\n    // use JS find() method which accepts a boolean function (a 'predicate')\n    /** predicate anonymous function:\n     *  - look through this list of _authors\n     *  - find the author that has id equal to the id passed in\n     */\n\n    return _authors.find((author) => author.id === id);\n  }\n\n  // redirect if author not found\n  authorFound(id) {\n    // search for authors that match the id\n    if (_authors.filter((author) => author.id === id).length > 0) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n}\n\n// instantiate class\nconst authorStore = new AuthorStore();\n\n/** dispatcher registration is private to the store\n *  thus defined below the store and not part of the\n *  public api.\n */\n\n/** register method accepts a function that takes in\n *  an action.\n *  this function will be called/notified of every\n *  single action dispatched.\n *  So we will need a function that switches based on\n *  the actionType that's being passed.\n */\n\n// Register/subscribe to the dispatcher\nDispatcher.register((payload) => {\n  // based on action dispatched\n  switch (payload.actionType) {\n    // create a new author and save it in a private store array\n    case actionTypes.CREATE_AUTHOR:\n      _authors.push(payload.author);\n      /** action.author gets a author from the payload\n       *  dispatched by api functions in authorActions.js\n       *  action.actionType checked for in the switch\n       *  declaration gets the actionType from the same\n       *  dispatcher payload.\n       *  i.e. the action is dispatched in authorActions.js\n       *  by Dispatcher.dispatch() and caught here via\n       *  Dispatcher.register().\n       *\n       *  Remember the _author data is private so people\n       *  can't mess with it. We need a getAuthors method\n       *  to access author data. Let's define it inside\n       *  the class (we are outside the class here) below\n       *  the emitChange() method.\n       *\n       */\n\n      // emit this change made to the store\n      authorStore.emitChange();\n      /** emitting a change, will notify any component\n       *  registered with the store. The component will\n       *  know to update the UI accordingly.\n       *  More specifically, any store that calls\n       *  addChangeListener() method will be notified\n       *  every emitChange() is called.\n       */\n      break;\n\n    case actionTypes.GET_AUTHOR:\n      _authors = payload.author;\n      authorStore.emitChange();\n      break;\n\n    case actionTypes.LOAD_AUTHORS:\n      // load authors from payload in private store\n      _authors = payload.authors;\n      // anounce change to store\n      authorStore.emitChange();\n      // Next, decide when to use this action and update AuthorsPage\n      /** When do we want the full authors list to load?\n       *  1. When needed (Lazy loading data)?\n       *     - requires a check to see if authors have been loaded\n       *       on each page that needs author data.\n       *\n       *  2. When the app loads regardless of page user is on?\n       *     - if the app needs the same data on many pages, it\n       *       may be better to load the data immediately when the\n       *       app loads regardless of page.\n       *\n       *  (For this app we'll implement lazy loading for learning.)\n       */\n      break;\n\n    case actionTypes.UPDATE_AUTHOR:\n      /**\n       *  Map over the _authors array and replace the author we want to update.\n       *  (map creates a new array by iterating an existing array.\n       *  we specify what value to put in the new array for each\n       *  element currently in the array.)\n       *  - update private array of authors by mapping over the existing array\n       *  - for each author check if author.id is equal to the action.author.id\n       *  - if true, replace that author with the action.author\n       *  - else leave as is\n       */\n      _authors = _authors.map((author) =>\n        author.id === payload.author.id ? payload.author : author\n      );\n\n      authorStore.emitChange();\n      break;\n\n    // delete author\n    case actionTypes.DELETE_AUTHOR:\n      _authors = _authors.filter(\n        /** for each author in _authors, check if author.id equals action.id (parse to Int possible string\n         *  and set radix to base 10)\n         *  if function returns true, filter out the match that was deleted.\n         *  this will return a new array of authors with one less author.\n         */\n        (author) => author.id !== parseInt(payload.id, 10) // for filter we pass it a boolean function (a predicate)\n      );\n      authorStore.emitChange();\n      // Next, implement the UI\n      break;\n\n    default:\n    // nothing to do\n    /** Every store's dispatcher receives every action\n     *  dispatched, so if the store isn't interested in\n     *  that action, there's nothing to do.\n     */\n  }\n});\n\n// export store\nexport default authorStore;\n"]},"metadata":{},"sourceType":"module"}