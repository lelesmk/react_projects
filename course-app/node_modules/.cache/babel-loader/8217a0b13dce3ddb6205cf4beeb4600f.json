{"ast":null,"code":"import dispatcher from \"../appDispatcher\"; // import authorApi to implement action calls to api\n\nimport * as authorApi from \"../api/authorApi\";\nimport actionTypes from \"./actionTypes\"; // ! the below function is called an Action Creator ! //\n\nexport function saveAuthor(author) {\n  // call authorApi to save a author passed in by this function\n\n  /** return the promise from the call to api so\n   *  the caller of this function will be notified\n   *  when the promise resolves/completes */\n  return authorApi.saveAuthor(author).then(savedAuthor => {\n    // returns savedAuthor\n    // handle saved author response\n\n    /** use flux dispatcher to notify all the stores\n     *  that a author was just created. Stores will\n     *  take the data payload dispatched here and\n     *  put it to use.\n     */\n    dispatcher.dispatch( // an action is an object with actionType property\n    {\n      // ! the below properties declared make up the Action ! //\n      // required property\n      // actionType: \"CREATE_AUTHOR\",\n\n      /**\n       *  actionType is hardcoded as a magic string.\n       *  this requires carefully typing it the\n       *  exact same way when declaring the store\n       *  which will handle the action.\n       *\n       *  instead its best practice to create a\n       *  constant file that contains a list of\n       *  all the actionTypes used in the system\n       *  (actionType is a constant so assigned\n       *  with uppercase.)\n       *\n       */\n      // call actionTypes object instead of hardcoding\n\n      /** call action based on whether a we're working on\n       *  an existing author or new author.\n       */\n      actionType: author.id // if author has an id\n      ? actionTypes.UPDATE_AUTHOR // then UPDATE\n      : actionTypes.CREATE_AUTHOR,\n      // else CREATE\n      // optional properties to pass with action object\n      author: savedAuthor\n    });\n  });\n} // declare flux call to api\n\nexport function loadAuthors() {\n  return authorApi.getAuthors().then(authors => {\n    // returns authors array\n    // dispatch authors array payload with action\n    dispatcher.dispatch({\n      actionType: actionTypes.LOAD_AUTHORS,\n      authors: authors\n    });\n  }); // Next, update the authorStore to handle this actionType\n} // delete author by id\n\nexport function deleteAuthor(id) {\n  return authorApi.deleteAuthor(id).then(() => {\n    // empty return ()\n    // dispatch authors array payload with action\n    dispatcher.dispatch({\n      actionType: actionTypes.DELETE_AUTHOR,\n      id: id\n    });\n  });\n}","map":{"version":3,"sources":["/Users/LelethuMkefa/dev/js-course/react-flux-app/src/actions/authorActions.js"],"names":["dispatcher","authorApi","actionTypes","saveAuthor","author","then","savedAuthor","dispatch","actionType","id","UPDATE_AUTHOR","CREATE_AUTHOR","loadAuthors","getAuthors","authors","LOAD_AUTHORS","deleteAuthor","DELETE_AUTHOR"],"mappings":"AAAA,OAAOA,UAAP,MAAuB,kBAAvB,C,CAEA;;AACA,OAAO,KAAKC,SAAZ,MAA2B,kBAA3B;AAEA,OAAOC,WAAP,MAAwB,eAAxB,C,CAEA;;AACA,OAAO,SAASC,UAAT,CAAoBC,MAApB,EAA4B;AACjC;;AACA;;;AAGA,SAAOH,SAAS,CAACE,UAAV,CAAqBC,MAArB,EAA6BC,IAA7B,CAAmCC,WAAD,IAAiB;AACxD;AACA;;AACA;;;;;AAKAN,IAAAA,UAAU,CAACO,QAAX,EACE;AACA;AACE;AAEA;AAEA;;AACA;;;;;;;;;;;;;AAcA;;AAEA;;;AAGAC,MAAAA,UAAU,EAAEJ,MAAM,CAACK,EAAP,CAAU;AAAV,QACRP,WAAW,CAACQ,aADJ,CACkB;AADlB,QAERR,WAAW,CAACS,aA3BlB;AA2BiC;AAE/B;AACAP,MAAAA,MAAM,EAAEE;AA9BV,KAFF;AAmCD,GA3CM,CAAP;AA4CD,C,CAED;;AACA,OAAO,SAASM,WAAT,GAAuB;AAC5B,SAAOX,SAAS,CAACY,UAAV,GAAuBR,IAAvB,CAA6BS,OAAD,IAAa;AAC9C;AACA;AACAd,IAAAA,UAAU,CAACO,QAAX,CAAoB;AAClBC,MAAAA,UAAU,EAAEN,WAAW,CAACa,YADN;AAElBD,MAAAA,OAAO,EAAEA;AAFS,KAApB;AAID,GAPM,CAAP,CAD4B,CAU5B;AACD,C,CAED;;AACA,OAAO,SAASE,YAAT,CAAsBP,EAAtB,EAA0B;AAC/B,SAAOR,SAAS,CAACe,YAAV,CAAuBP,EAAvB,EAA2BJ,IAA3B,CAAgC,MAAM;AAC3C;AACA;AACAL,IAAAA,UAAU,CAACO,QAAX,CAAoB;AAClBC,MAAAA,UAAU,EAAEN,WAAW,CAACe,aADN;AAElBR,MAAAA,EAAE,EAAEA;AAFc,KAApB;AAID,GAPM,CAAP;AAQD","sourcesContent":["import dispatcher from \"../appDispatcher\";\n\n// import authorApi to implement action calls to api\nimport * as authorApi from \"../api/authorApi\";\n\nimport actionTypes from \"./actionTypes\";\n\n// ! the below function is called an Action Creator ! //\nexport function saveAuthor(author) {\n  // call authorApi to save a author passed in by this function\n  /** return the promise from the call to api so\n   *  the caller of this function will be notified\n   *  when the promise resolves/completes */\n  return authorApi.saveAuthor(author).then((savedAuthor) => {\n    // returns savedAuthor\n    // handle saved author response\n    /** use flux dispatcher to notify all the stores\n     *  that a author was just created. Stores will\n     *  take the data payload dispatched here and\n     *  put it to use.\n     */\n    dispatcher.dispatch(\n      // an action is an object with actionType property\n      {\n        // ! the below properties declared make up the Action ! //\n\n        // required property\n\n        // actionType: \"CREATE_AUTHOR\",\n        /**\n         *  actionType is hardcoded as a magic string.\n         *  this requires carefully typing it the\n         *  exact same way when declaring the store\n         *  which will handle the action.\n         *\n         *  instead its best practice to create a\n         *  constant file that contains a list of\n         *  all the actionTypes used in the system\n         *  (actionType is a constant so assigned\n         *  with uppercase.)\n         *\n         */\n\n        // call actionTypes object instead of hardcoding\n\n        /** call action based on whether a we're working on\n         *  an existing author or new author.\n         */\n        actionType: author.id // if author has an id\n          ? actionTypes.UPDATE_AUTHOR // then UPDATE\n          : actionTypes.CREATE_AUTHOR, // else CREATE\n\n        // optional properties to pass with action object\n        author: savedAuthor,\n      }\n    );\n  });\n}\n\n// declare flux call to api\nexport function loadAuthors() {\n  return authorApi.getAuthors().then((authors) => {\n    // returns authors array\n    // dispatch authors array payload with action\n    dispatcher.dispatch({\n      actionType: actionTypes.LOAD_AUTHORS,\n      authors: authors,\n    });\n  });\n\n  // Next, update the authorStore to handle this actionType\n}\n\n// delete author by id\nexport function deleteAuthor(id) {\n  return authorApi.deleteAuthor(id).then(() => {\n    // empty return ()\n    // dispatch authors array payload with action\n    dispatcher.dispatch({\n      actionType: actionTypes.DELETE_AUTHOR,\n      id: id,\n    });\n  });\n}\n"]},"metadata":{},"sourceType":"module"}