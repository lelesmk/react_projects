{"ast":null,"code":"import _classCallCheck from\"/Users/LelethuMkefa/dev/js-course/react-flux-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/classCallCheck\";import _createClass from\"/Users/LelethuMkefa/dev/js-course/react-flux-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createClass\";import _createSuper from\"/Users/LelethuMkefa/dev/js-course/react-flux-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/createSuper\";import _inherits from\"/Users/LelethuMkefa/dev/js-course/react-flux-app/node_modules/babel-preset-react-app/node_modules/@babel/runtime/helpers/esm/inherits\";import{EventEmitter}from\"events\";import Dispatcher from\"../appDispatcher\";// import actionTypes to bundle with the new course\nimport actionTypes from\"../actions/actionTypes\";/** store needs to emit an event each time\n *  a change occurs. Extend EventEmitter class\n *  to get this behaviour.\n *\n *  ! see node.js docs for events emitter methods. */ // declare event constant to avoid hardcoding\nvar CHANGE_EVENT=\"change\";// declare a private array to store course data\nvar _courses=[];/** course data is not exported/made public - only\n *  the store is exported. The only way to access\n *  the course data will be via public api which\n *  are the functions we declare in this module.\n *  So we can control how course data is managed.\n *\n *  Everytime a courseStore is created, the\n *  CREATE_COURSE action will be dispatched. It will\n *  include the new course as part of the payload.\n *\n *  So we want to take a new course that will be\n *  passed with the action and push it into an array\n *  that stores course data. This implementation is\n *  executed inside the code block where we register\n *  the store to the dispatcher.\n */var CourseStore=/*#__PURE__*/function(_EventEmitter){_inherits(CourseStore,_EventEmitter);var _super=_createSuper(CourseStore);function CourseStore(){_classCallCheck(this,CourseStore);return _super.apply(this,arguments);}_createClass(CourseStore,[{key:\"addChangeListener\",/**\n   *  the below methods provides a way for the UI/React\n   *  components to interact with the store.\n   *  every Flux store must have these 3 functions:\n   *  1. addChangeListener (wraps EventEmitter's 'on' method)\n   *  2. removeChangeListener (wraps EventEmitter's 'removeListener' method)\n   *  3. emitChange (wraps EventEmitter's 'emit' method)\n   */ // add listener function to listeners array for the event\nvalue:function addChangeListener(callback){// call on to watch for 'change' event\nthis.on(CHANGE_EVENT,// when change occurs we will call the callback function\ncallback);/** this method will allow react components to subscribe\n     *  to the store to get notified when a chance occurs.\n     *  whatever callback function gets passed in will be\n     *  called anytime things change in the store.\n     */}// remove specified listner from the listener array for the event\n},{key:\"removeChangeListener\",value:function removeChangeListener(callback){this.removeListener(CHANGE_EVENT,callback);/** this method will allow react components to unsubscribe\n     *  from the store.\n     */}// synchronously calls each listener registered for the event, in order of register\n},{key:\"emitChange\",value:function emitChange(){this.emit(CHANGE_EVENT);}// give read access to private variable _courses\n},{key:\"getCourses\",value:function getCourses(){return _courses;}// find course by slug\n},{key:\"getCourseBySlug\",value:function getCourseBySlug(slug){// use JS find() method which accepts a boolean function (a 'predicate')\n/** predicate anonymous function:\n     *  - look through this list of _courses\n     *  - find the course that has slug equal to the slug passed in\n     */return _courses.find(function(course){return course.slug===slug;});}// redirect if course not found\n},{key:\"courseFound\",value:function courseFound(slug){// search for courses that match the slug\nif(_courses.filter(function(course){return course.slug===slug;}).length>0){return true;}else{return false;}}// TODO: Add other handy functions that searches course data\n}]);return CourseStore;}(EventEmitter);// instantiate class\nvar courseStore=new CourseStore();/** dispatcher registration is private to the store\n *  thus defined below the store and not part of the\n *  public api.\n */ /** register method accepts a function that takes in\n *  a payload.\n *  this function will be called/notified of every\n *  single action dispatched.\n *  So we will need a function that switches based on\n *  the actionType that's being passed.\n */ // Register/subscribe to the dispatcher\nDispatcher.register(function(payload){// based on payload dispatched\nswitch(payload.actionType){// create a new course and save it in a private store array\ncase actionTypes.CREATE_COURSE:_courses.push(payload.course);/** payload.course gets a course from the payload\n       *  dispatched by api functions in courseActions.js\n       *  payload.actionType checked for in the switch\n       *  declaration gets the actionType from the same\n       *  dispatcher payload.\n       *  i.e. the payload is dispatched in courseActions.js\n       *  by Dispatcher.dispatch() and caught here via\n       *  Dispatcher.register().\n       *\n       *  Remember the _course data is private so people\n       *  can't mess with it. We need a getCourses method\n       *  to access course data. Let's define it inside\n       *  the class (we are outside the class here) below\n       *  the emitChange() method.\n       *\n       */ // emit this change made to the store\ncourseStore.emitChange();/** emitting a change, will notify any component\n       *  registered with the store. The component will\n       *  know to update the UI accordingly.\n       *  More specifically, any store that calls\n       *  addChangeListener() method will be notified\n       *  every emitChange() is called.\n       */break;case actionTypes.LOAD_COURSES:// load courses from payload in private store\n_courses=payload.courses;// anounce change to store\ncourseStore.emitChange();// Next, decide when to use this action and update CoursesPage\n/** When do we want the full courses list to load?\n       *  1. When needed (Lazy loading data)?\n       *     - requires a check to see if courses have been loaded\n       *       on each page that needs course data.\n       *\n       *  2. When the app loads regardless of page user is on?\n       *     - if the app needs the same data on many pages, it\n       *       may be better to load the data immediately when the\n       *       app loads regardless of page.\n       *\n       *  (For this app we'll implement lazy loading for learning.)\n       */break;case actionTypes.UPDATE_COURSE:/**\n       *  Map over the _courses array and replace the course we want to update.\n       *  (map creates a new array by iterating an existing array.\n       *  we specify what value to put in the new array for each\n       *  element currently in the array.)\n       *  - update private array of courses by mapping over the existing array\n       *  - for each course check if course.id is equal to the payload.course.id\n       *  - if true, replace that course with the payload.course\n       *  - else leave as is\n       */_courses=_courses.map(function(course){return course.id===payload.course.id?payload.course:course;});courseStore.emitChange();break;// delete course\ncase actionTypes.DELETE_COURSE:_courses=_courses.filter(/** for each course in _courses, check if course.id equals payload.id (parse to Int possible string\n         *  and set radix to base 10)\n         *  if function returns true, filter out the match that was deleted.\n         *  this will return a new array of courses with one less course.\n         */function(course){return course.id!==parseInt(payload.id,10);}// for filter we pass it a boolean function (a predicate)\n);courseStore.emitChange();// Next, implement the UI\nbreak;default:// nothing to do\n/** Every store's dispatcher receives every action\n     *  dispatched, so if the store isn't interested in\n     *  that action, there's nothing to do.\n     */}});// export store\nexport default courseStore;/** next, register store with dispatcher so\n *  the store is  notified when an action occurs.*/ //====== BOILERPLATE CODE FOR STORES ====== //\n//========= The shell of a store ========= //\n/**\n *  1. Create a class that extends the EventEmitter\n *     to emit an event when an action produced\n *  2. Implement 3 EventEmitter functions to interact with UI\n *     (addChangeListener, removeChangeListener, emitChange)\n *  3. Create an instance of the store\n *  4. Register to the dispatcher so the store get's\n *     called/notified based on the actionType being passed.\n *  5. Implement the action (e.g. create courses and store),\n *     emit the changes, and create methods that access the data.\n *     The CourseStore holds the full list of courses now. React\n *     components/UI don't need to call the api directly to get\n *     course data. All they need to do is call store's methods.\n *\n *  NB! Redux a version of Flux avoids some of this\n *      implementation code. But this understanding makes\n *      it easier to learn Redux. Redux builds upon these\n *      principles.\n */","map":{"version":3,"sources":["/Users/LelethuMkefa/dev/js-course/react-flux-app/src/stores/courseStore.js"],"names":["EventEmitter","Dispatcher","actionTypes","CHANGE_EVENT","_courses","CourseStore","callback","on","removeListener","emit","slug","find","course","filter","length","courseStore","register","payload","actionType","CREATE_COURSE","push","emitChange","LOAD_COURSES","courses","UPDATE_COURSE","map","id","DELETE_COURSE","parseInt"],"mappings":"4oBAAA,OAASA,YAAT,KAA6B,QAA7B,CAEA,MAAOC,CAAAA,UAAP,KAAuB,kBAAvB,CAEA;AACA,MAAOC,CAAAA,WAAP,KAAwB,wBAAxB,CAEA;;;;sDAMA;AACA,GAAMC,CAAAA,YAAY,CAAG,QAArB,CAEA;AACA,GAAIC,CAAAA,QAAQ,CAAG,EAAf,CACA;;;;;;;;;;;;;;;MAiBMC,CAAAA,W,iQACJ;;;;;;;MAQA;iCACkBC,Q,CAAU,CAC1B;AACA,KAAKC,EAAL,CACEJ,YADF,CAEE;AACAG,QAHF,EAKA;;;;OAKD,CAED;kEACqBA,Q,CAAU,CAC7B,KAAKE,cAAL,CAAoBL,YAApB,CAAkCG,QAAlC,EACA;;OAGD,CACD;+CACa,CACX,KAAKG,IAAL,CAAUN,YAAV,EACD,CAED;+CACa,CACX,MAAOC,CAAAA,QAAP,CACD,CAED;wDACgBM,I,CAAM,CACpB;AACA;;;OAKA,MAAON,CAAAA,QAAQ,CAACO,IAAT,CAAc,SAACC,MAAD,QAAYA,CAAAA,MAAM,CAACF,IAAP,GAAgBA,IAA5B,EAAd,CAAP,CACD,CAED;gDACYA,I,CAAM,CAChB;AACA,GAAIN,QAAQ,CAACS,MAAT,CAAgB,SAACD,MAAD,QAAYA,CAAAA,MAAM,CAACF,IAAP,GAAgBA,IAA5B,EAAhB,EAAkDI,MAAlD,CAA2D,CAA/D,CAAkE,CAChE,MAAO,KAAP,CACD,CAFD,IAEO,CACL,MAAO,MAAP,CACD,CACF,CAED;yBA9DwBd,Y,EAiE1B;AACA,GAAMe,CAAAA,WAAW,CAAG,GAAIV,CAAAA,WAAJ,EAApB,CAEA;;;IAKA;;;;;;IAQA;AACAJ,UAAU,CAACe,QAAX,CAAoB,SAACC,OAAD,CAAa,CAC/B;AACA,OAAQA,OAAO,CAACC,UAAhB,EACE;AACA,IAAKhB,CAAAA,WAAW,CAACiB,aAAjB,CACEf,QAAQ,CAACgB,IAAT,CAAcH,OAAO,CAACL,MAAtB,EACA;;;;;;;;;;;;;;;SAFF,CAmBE;AACAG,WAAW,CAACM,UAAZ,GACA;;;;;;SAOA,MAEF,IAAKnB,CAAAA,WAAW,CAACoB,YAAjB,CACE;AACAlB,QAAQ,CAAGa,OAAO,CAACM,OAAnB,CACA;AACAR,WAAW,CAACM,UAAZ,GACA;AACA;;;;;;;;;;;SAYA,MAEF,IAAKnB,CAAAA,WAAW,CAACsB,aAAjB,CACE;;;;;;;;;SAUApB,QAAQ,CAAGA,QAAQ,CAACqB,GAAT,CAAa,SAACb,MAAD,QACtBA,CAAAA,MAAM,CAACc,EAAP,GAAcT,OAAO,CAACL,MAAR,CAAec,EAA7B,CAAkCT,OAAO,CAACL,MAA1C,CAAmDA,MAD7B,EAAb,CAAX,CAIAG,WAAW,CAACM,UAAZ,GACA,MAEF;AACA,IAAKnB,CAAAA,WAAW,CAACyB,aAAjB,CACEvB,QAAQ,CAAGA,QAAQ,CAACS,MAAT,CACT;;;;WAKA,SAACD,MAAD,QAAYA,CAAAA,MAAM,CAACc,EAAP,GAAcE,QAAQ,CAACX,OAAO,CAACS,EAAT,CAAa,EAAb,CAAlC,EAAmD;AAN1C,CAAX,CAQAX,WAAW,CAACM,UAAZ,GACA;AACA,MAEF,QACA;AACA;;;OAtFF,CA2FD,CA7FD,EA+FA;AACA,cAAeN,CAAAA,WAAf,CAEA;oDAGA;AACA;AAEA","sourcesContent":["import { EventEmitter } from \"events\";\n\nimport Dispatcher from \"../appDispatcher\";\n\n// import actionTypes to bundle with the new course\nimport actionTypes from \"../actions/actionTypes\";\n\n/** store needs to emit an event each time\n *  a change occurs. Extend EventEmitter class\n *  to get this behaviour.\n *\n *  ! see node.js docs for events emitter methods. */\n\n// declare event constant to avoid hardcoding\nconst CHANGE_EVENT = \"change\";\n\n// declare a private array to store course data\nlet _courses = [];\n/** course data is not exported/made public - only\n *  the store is exported. The only way to access\n *  the course data will be via public api which\n *  are the functions we declare in this module.\n *  So we can control how course data is managed.\n *\n *  Everytime a courseStore is created, the\n *  CREATE_COURSE action will be dispatched. It will\n *  include the new course as part of the payload.\n *\n *  So we want to take a new course that will be\n *  passed with the action and push it into an array\n *  that stores course data. This implementation is\n *  executed inside the code block where we register\n *  the store to the dispatcher.\n */\n\nclass CourseStore extends EventEmitter {\n  /**\n   *  the below methods provides a way for the UI/React\n   *  components to interact with the store.\n   *  every Flux store must have these 3 functions:\n   *  1. addChangeListener (wraps EventEmitter's 'on' method)\n   *  2. removeChangeListener (wraps EventEmitter's 'removeListener' method)\n   *  3. emitChange (wraps EventEmitter's 'emit' method)\n   */\n  // add listener function to listeners array for the event\n  addChangeListener(callback) {\n    // call on to watch for 'change' event\n    this.on(\n      CHANGE_EVENT,\n      // when change occurs we will call the callback function\n      callback\n    );\n    /** this method will allow react components to subscribe\n     *  to the store to get notified when a chance occurs.\n     *  whatever callback function gets passed in will be\n     *  called anytime things change in the store.\n     */\n  }\n\n  // remove specified listner from the listener array for the event\n  removeChangeListener(callback) {\n    this.removeListener(CHANGE_EVENT, callback);\n    /** this method will allow react components to unsubscribe\n     *  from the store.\n     */\n  }\n  // synchronously calls each listener registered for the event, in order of register\n  emitChange() {\n    this.emit(CHANGE_EVENT);\n  }\n\n  // give read access to private variable _courses\n  getCourses() {\n    return _courses;\n  }\n\n  // find course by slug\n  getCourseBySlug(slug) {\n    // use JS find() method which accepts a boolean function (a 'predicate')\n    /** predicate anonymous function:\n     *  - look through this list of _courses\n     *  - find the course that has slug equal to the slug passed in\n     */\n\n    return _courses.find((course) => course.slug === slug);\n  }\n\n  // redirect if course not found\n  courseFound(slug) {\n    // search for courses that match the slug\n    if (_courses.filter((course) => course.slug === slug).length > 0) {\n      return true;\n    } else {\n      return false;\n    }\n  }\n\n  // TODO: Add other handy functions that searches course data\n}\n\n// instantiate class\nconst courseStore = new CourseStore();\n\n/** dispatcher registration is private to the store\n *  thus defined below the store and not part of the\n *  public api.\n */\n\n/** register method accepts a function that takes in\n *  a payload.\n *  this function will be called/notified of every\n *  single action dispatched.\n *  So we will need a function that switches based on\n *  the actionType that's being passed.\n */\n\n// Register/subscribe to the dispatcher\nDispatcher.register((payload) => {\n  // based on payload dispatched\n  switch (payload.actionType) {\n    // create a new course and save it in a private store array\n    case actionTypes.CREATE_COURSE:\n      _courses.push(payload.course);\n      /** payload.course gets a course from the payload\n       *  dispatched by api functions in courseActions.js\n       *  payload.actionType checked for in the switch\n       *  declaration gets the actionType from the same\n       *  dispatcher payload.\n       *  i.e. the payload is dispatched in courseActions.js\n       *  by Dispatcher.dispatch() and caught here via\n       *  Dispatcher.register().\n       *\n       *  Remember the _course data is private so people\n       *  can't mess with it. We need a getCourses method\n       *  to access course data. Let's define it inside\n       *  the class (we are outside the class here) below\n       *  the emitChange() method.\n       *\n       */\n\n      // emit this change made to the store\n      courseStore.emitChange();\n      /** emitting a change, will notify any component\n       *  registered with the store. The component will\n       *  know to update the UI accordingly.\n       *  More specifically, any store that calls\n       *  addChangeListener() method will be notified\n       *  every emitChange() is called.\n       */\n      break;\n\n    case actionTypes.LOAD_COURSES:\n      // load courses from payload in private store\n      _courses = payload.courses;\n      // anounce change to store\n      courseStore.emitChange();\n      // Next, decide when to use this action and update CoursesPage\n      /** When do we want the full courses list to load?\n       *  1. When needed (Lazy loading data)?\n       *     - requires a check to see if courses have been loaded\n       *       on each page that needs course data.\n       *\n       *  2. When the app loads regardless of page user is on?\n       *     - if the app needs the same data on many pages, it\n       *       may be better to load the data immediately when the\n       *       app loads regardless of page.\n       *\n       *  (For this app we'll implement lazy loading for learning.)\n       */\n      break;\n\n    case actionTypes.UPDATE_COURSE:\n      /**\n       *  Map over the _courses array and replace the course we want to update.\n       *  (map creates a new array by iterating an existing array.\n       *  we specify what value to put in the new array for each\n       *  element currently in the array.)\n       *  - update private array of courses by mapping over the existing array\n       *  - for each course check if course.id is equal to the payload.course.id\n       *  - if true, replace that course with the payload.course\n       *  - else leave as is\n       */\n      _courses = _courses.map((course) =>\n        course.id === payload.course.id ? payload.course : course\n      );\n\n      courseStore.emitChange();\n      break;\n\n    // delete course\n    case actionTypes.DELETE_COURSE:\n      _courses = _courses.filter(\n        /** for each course in _courses, check if course.id equals payload.id (parse to Int possible string\n         *  and set radix to base 10)\n         *  if function returns true, filter out the match that was deleted.\n         *  this will return a new array of courses with one less course.\n         */\n        (course) => course.id !== parseInt(payload.id, 10) // for filter we pass it a boolean function (a predicate)\n      );\n      courseStore.emitChange();\n      // Next, implement the UI\n      break;\n\n    default:\n    // nothing to do\n    /** Every store's dispatcher receives every action\n     *  dispatched, so if the store isn't interested in\n     *  that action, there's nothing to do.\n     */\n  }\n});\n\n// export store\nexport default courseStore;\n\n/** next, register store with dispatcher so\n *  the store is  notified when an action occurs.*/\n\n//====== BOILERPLATE CODE FOR STORES ====== //\n//========= The shell of a store ========= //\n\n/**\n *  1. Create a class that extends the EventEmitter\n *     to emit an event when an action produced\n *  2. Implement 3 EventEmitter functions to interact with UI\n *     (addChangeListener, removeChangeListener, emitChange)\n *  3. Create an instance of the store\n *  4. Register to the dispatcher so the store get's\n *     called/notified based on the actionType being passed.\n *  5. Implement the action (e.g. create courses and store),\n *     emit the changes, and create methods that access the data.\n *     The CourseStore holds the full list of courses now. React\n *     components/UI don't need to call the api directly to get\n *     course data. All they need to do is call store's methods.\n *\n *  NB! Redux a version of Flux avoids some of this\n *      implementation code. But this understanding makes\n *      it easier to learn Redux. Redux builds upon these\n *      principles.\n */\n"]},"metadata":{},"sourceType":"module"}